//   NOTE: this is a machine generated file--editing not recommended
//
// sm_x501if.h - class definitions for ASN.1 module InformationFramework
//
//   This file was generated by snacc on Wed Jun 27 16:40:55 2001
//   UBC snacc by Mike Sample
//   A couple of enhancements made by IBM European Networking Center

#ifndef _sm_x501if_h_
#define _sm_x501if_h_


//------------------------------------------------------------------------------
// class declarations:

class AttributeTypeAndDistinguishedValueSetOfSeqSetOf;
class AttributeTypeAndDistinguishedValueSetOfSeq;
class AttributeTypeAndDistinguishedValueSetOf;
class AttributeSetOf;
class Attribute;
class AttributeTypeAndDistinguishedValue;
class RelativeDistinguishedName;
class RDNSequence;
class Attributes;
class Name;

//------------------------------------------------------------------------------
// class definitions:

typedef enum InformationFrameworkAnyId
{

} InformationFrameworkAnyId;


/* OBJECT IDENTIFIER */
typedef AsnOid AttributeType;

/* ANY */
typedef AsnAny AttributeValue;

class AttributeTypeAndDistinguishedValueSetOfSeqSetOf: public AsnType
{
protected:
  unsigned long int	count;
  struct AsnListElmt
  {
    AsnListElmt	*next;
    AsnListElmt	*prev;
    AsnAny	*elmt;
  }			*first, *curr, *last;

public:
			AttributeTypeAndDistinguishedValueSetOfSeqSetOf() { count = 0; first = curr = last = NULL; }
			AttributeTypeAndDistinguishedValueSetOfSeqSetOf (const AttributeTypeAndDistinguishedValueSetOfSeqSetOf &);
  virtual		~AttributeTypeAndDistinguishedValueSetOfSeqSetOf();
  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  AttributeTypeAndDistinguishedValueSetOfSeqSetOf		&operator = (const AttributeTypeAndDistinguishedValueSetOfSeqSetOf &);
  void		SetCurrElmt (unsigned long int index);
  unsigned long int	GetCurrElmtIndex();
  void		SetCurrToFirst() { curr = first; }
  void		SetCurrToLast()  { curr = last; }
  // reading member fcns
  int			Count() const	{ return count; }
  // NOTE: if your compiler complains about these NULLs, its definition of NULL is broken (and you better change it there!)
  AsnAny	*First() const	{ return count > 0 ? first->elmt : NULL; }
  AsnAny	*Last() const	{ return count > 0 ? last->elmt : NULL; }
  AsnAny	*Curr() const	{ return curr ? curr->elmt : NULL; }
  AsnAny	*Next() const	{ return curr && curr->next ? curr->next->elmt : NULL; }
  AsnAny	*Prev() const	{ return curr && curr->prev ? curr->prev->elmt : NULL; }

  // routines that move the curr elmt
  AsnAny	*GoNext() { if (curr) curr = curr->next; return Curr(); }
  AsnAny	*GoPrev() { if (curr) curr = curr->prev; return Curr(); }

  // write & alloc fcns - returns new elmt
  AsnAny	*Append();  // add elmt to end of list
  AsnAny	*Prepend(); // add elmt to beginning of list
  AsnAny	*InsertBefore(); //insert elmt before current elmt
  AsnAny	*InsertAfter(); //insert elmt after current elmt

  // write & alloc & copy - returns list after copying elmt
  AttributeTypeAndDistinguishedValueSetOfSeqSetOf	&AppendCopy (AsnAny &elmt);  // add elmt to end of list
  AttributeTypeAndDistinguishedValueSetOfSeqSetOf	&PrependCopy (AsnAny &elmt); // add elmt to beginning of list
  AttributeTypeAndDistinguishedValueSetOfSeqSetOf	&InsertBeforeAndCopy (AsnAny &elmt); //insert elmt before current elmt
  AttributeTypeAndDistinguishedValueSetOfSeqSetOf	&InsertAfterAndCopy (AsnAny &elmt); //insert elmt after current elmt

  // removing the current elmt from the list
  void		RemoveCurrFromList();

  // encode and decode routines    
  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  PDU_MEMBER_MACROS
  void		Print (ostream &os) const;
};


class AttributeTypeAndDistinguishedValueSetOfSeq: public AsnType
{
public:
  AsnOid		*distingAttrValue;
  AttributeTypeAndDistinguishedValueSetOfSeqSetOf		contextList;

			AttributeTypeAndDistinguishedValueSetOfSeq();
			AttributeTypeAndDistinguishedValueSetOfSeq (const AttributeTypeAndDistinguishedValueSetOfSeq &);
  virtual		~AttributeTypeAndDistinguishedValueSetOfSeq();
  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  AttributeTypeAndDistinguishedValueSetOfSeq		&operator = (const AttributeTypeAndDistinguishedValueSetOfSeq &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  int			BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded);
  int			BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded);

  void		Print (ostream &os) const;
};


class AttributeTypeAndDistinguishedValueSetOf: public AsnType
{
protected:
  unsigned long int	count;
  struct AsnListElmt
  {
    AsnListElmt	*next;
    AsnListElmt	*prev;
    AttributeTypeAndDistinguishedValueSetOfSeq	*elmt;
  }			*first, *curr, *last;

public:
			AttributeTypeAndDistinguishedValueSetOf() { count = 0; first = curr = last = NULL; }
			AttributeTypeAndDistinguishedValueSetOf (const AttributeTypeAndDistinguishedValueSetOf &);
  virtual		~AttributeTypeAndDistinguishedValueSetOf();
  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  AttributeTypeAndDistinguishedValueSetOf		&operator = (const AttributeTypeAndDistinguishedValueSetOf &);
  void		SetCurrElmt (unsigned long int index);
  unsigned long int	GetCurrElmtIndex();
  void		SetCurrToFirst() { curr = first; }
  void		SetCurrToLast()  { curr = last; }
  // reading member fcns
  int			Count() const	{ return count; }
  // NOTE: if your compiler complains about these NULLs, its definition of NULL is broken (and you better change it there!)
  AttributeTypeAndDistinguishedValueSetOfSeq	*First() const	{ return count > 0 ? first->elmt : NULL; }
  AttributeTypeAndDistinguishedValueSetOfSeq	*Last() const	{ return count > 0 ? last->elmt : NULL; }
  AttributeTypeAndDistinguishedValueSetOfSeq	*Curr() const	{ return curr ? curr->elmt : NULL; }
  AttributeTypeAndDistinguishedValueSetOfSeq	*Next() const	{ return curr && curr->next ? curr->next->elmt : NULL; }
  AttributeTypeAndDistinguishedValueSetOfSeq	*Prev() const	{ return curr && curr->prev ? curr->prev->elmt : NULL; }

  // routines that move the curr elmt
  AttributeTypeAndDistinguishedValueSetOfSeq	*GoNext() { if (curr) curr = curr->next; return Curr(); }
  AttributeTypeAndDistinguishedValueSetOfSeq	*GoPrev() { if (curr) curr = curr->prev; return Curr(); }

  // write & alloc fcns - returns new elmt
  AttributeTypeAndDistinguishedValueSetOfSeq	*Append();  // add elmt to end of list
  AttributeTypeAndDistinguishedValueSetOfSeq	*Prepend(); // add elmt to beginning of list
  AttributeTypeAndDistinguishedValueSetOfSeq	*InsertBefore(); //insert elmt before current elmt
  AttributeTypeAndDistinguishedValueSetOfSeq	*InsertAfter(); //insert elmt after current elmt

  // write & alloc & copy - returns list after copying elmt
  AttributeTypeAndDistinguishedValueSetOf	&AppendCopy (AttributeTypeAndDistinguishedValueSetOfSeq &elmt);  // add elmt to end of list
  AttributeTypeAndDistinguishedValueSetOf	&PrependCopy (AttributeTypeAndDistinguishedValueSetOfSeq &elmt); // add elmt to beginning of list
  AttributeTypeAndDistinguishedValueSetOf	&InsertBeforeAndCopy (AttributeTypeAndDistinguishedValueSetOfSeq &elmt); //insert elmt before current elmt
  AttributeTypeAndDistinguishedValueSetOf	&InsertAfterAndCopy (AttributeTypeAndDistinguishedValueSetOfSeq &elmt); //insert elmt after current elmt

  // removing the current elmt from the list
  void		RemoveCurrFromList();

  // encode and decode routines    
  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  PDU_MEMBER_MACROS
  void		Print (ostream &os) const;
};


class AttributeSetOf: public AsnType
{
protected:
  unsigned long int	count;
  struct AsnListElmt
  {
    AsnListElmt	*next;
    AsnListElmt	*prev;
    AttributeValue	*elmt;
  }			*first, *curr, *last;

public:
			AttributeSetOf() { count = 0; first = curr = last = NULL; }
			AttributeSetOf (const AttributeSetOf &);
  virtual		~AttributeSetOf();
  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  AttributeSetOf		&operator = (const AttributeSetOf &);
  void		SetCurrElmt (unsigned long int index);
  unsigned long int	GetCurrElmtIndex();
  void		SetCurrToFirst() { curr = first; }
  void		SetCurrToLast()  { curr = last; }
  // reading member fcns
  int			Count() const	{ return count; }
  // NOTE: if your compiler complains about these NULLs, its definition of NULL is broken (and you better change it there!)
  AttributeValue	*First() const	{ return count > 0 ? first->elmt : NULL; }
  AttributeValue	*Last() const	{ return count > 0 ? last->elmt : NULL; }
  AttributeValue	*Curr() const	{ return curr ? curr->elmt : NULL; }
  AttributeValue	*Next() const	{ return curr && curr->next ? curr->next->elmt : NULL; }
  AttributeValue	*Prev() const	{ return curr && curr->prev ? curr->prev->elmt : NULL; }

  // routines that move the curr elmt
  AttributeValue	*GoNext() { if (curr) curr = curr->next; return Curr(); }
  AttributeValue	*GoPrev() { if (curr) curr = curr->prev; return Curr(); }

  // write & alloc fcns - returns new elmt
  AttributeValue	*Append();  // add elmt to end of list
  AttributeValue	*Prepend(); // add elmt to beginning of list
  AttributeValue	*InsertBefore(); //insert elmt before current elmt
  AttributeValue	*InsertAfter(); //insert elmt after current elmt

  // write & alloc & copy - returns list after copying elmt
  AttributeSetOf	&AppendCopy (AttributeValue &elmt);  // add elmt to end of list
  AttributeSetOf	&PrependCopy (AttributeValue &elmt); // add elmt to beginning of list
  AttributeSetOf	&InsertBeforeAndCopy (AttributeValue &elmt); //insert elmt before current elmt
  AttributeSetOf	&InsertAfterAndCopy (AttributeValue &elmt); //insert elmt after current elmt

  // removing the current elmt from the list
  void		RemoveCurrFromList();

  // encode and decode routines    
  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  PDU_MEMBER_MACROS
  void		Print (ostream &os) const;
};


class Attribute: public AsnType
{
public:
  AttributeType		type;
  AttributeSetOf		values;

			Attribute();
			Attribute (const Attribute &);
  virtual		~Attribute();
  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  Attribute		&operator = (const Attribute &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  int			BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded);
  int			BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded);

  void		Print (ostream &os) const;
};


class AttributeTypeAndDistinguishedValue: public AsnType
{
public:
  AsnOid		type;
  AsnAny		value;
  AsnBool		*primaryDistinguished;
  AttributeTypeAndDistinguishedValueSetOf		*valuesWithContext;

			AttributeTypeAndDistinguishedValue();
			AttributeTypeAndDistinguishedValue (const AttributeTypeAndDistinguishedValue &);
  virtual		~AttributeTypeAndDistinguishedValue();
  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  AttributeTypeAndDistinguishedValue		&operator = (const AttributeTypeAndDistinguishedValue &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  int			BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded);
  int			BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded);

  void		Print (ostream &os) const;
};


class RelativeDistinguishedName: public AsnType
{
protected:
  unsigned long int	count;
  struct AsnListElmt
  {
    AsnListElmt	*next;
    AsnListElmt	*prev;
    AttributeTypeAndDistinguishedValue	*elmt;
  }			*first, *curr, *last;

public:
			RelativeDistinguishedName() { count = 0; first = curr = last = NULL; }
			RelativeDistinguishedName (const RelativeDistinguishedName &);
  virtual		~RelativeDistinguishedName();
  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  RelativeDistinguishedName		&operator = (const RelativeDistinguishedName &);
  void		SetCurrElmt (unsigned long int index);
  unsigned long int	GetCurrElmtIndex();
  void		SetCurrToFirst() { curr = first; }
  void		SetCurrToLast()  { curr = last; }
  // reading member fcns
  int			Count() const	{ return count; }
  // NOTE: if your compiler complains about these NULLs, its definition of NULL is broken (and you better change it there!)
  AttributeTypeAndDistinguishedValue	*First() const	{ return count > 0 ? first->elmt : NULL; }
  AttributeTypeAndDistinguishedValue	*Last() const	{ return count > 0 ? last->elmt : NULL; }
  AttributeTypeAndDistinguishedValue	*Curr() const	{ return curr ? curr->elmt : NULL; }
  AttributeTypeAndDistinguishedValue	*Next() const	{ return curr && curr->next ? curr->next->elmt : NULL; }
  AttributeTypeAndDistinguishedValue	*Prev() const	{ return curr && curr->prev ? curr->prev->elmt : NULL; }

  // routines that move the curr elmt
  AttributeTypeAndDistinguishedValue	*GoNext() { if (curr) curr = curr->next; return Curr(); }
  AttributeTypeAndDistinguishedValue	*GoPrev() { if (curr) curr = curr->prev; return Curr(); }

  // write & alloc fcns - returns new elmt
  AttributeTypeAndDistinguishedValue	*Append();  // add elmt to end of list
  AttributeTypeAndDistinguishedValue	*Prepend(); // add elmt to beginning of list
  AttributeTypeAndDistinguishedValue	*InsertBefore(); //insert elmt before current elmt
  AttributeTypeAndDistinguishedValue	*InsertAfter(); //insert elmt after current elmt

  // write & alloc & copy - returns list after copying elmt
  RelativeDistinguishedName	&AppendCopy (AttributeTypeAndDistinguishedValue &elmt);  // add elmt to end of list
  RelativeDistinguishedName	&PrependCopy (AttributeTypeAndDistinguishedValue &elmt); // add elmt to beginning of list
  RelativeDistinguishedName	&InsertBeforeAndCopy (AttributeTypeAndDistinguishedValue &elmt); //insert elmt before current elmt
  RelativeDistinguishedName	&InsertAfterAndCopy (AttributeTypeAndDistinguishedValue &elmt); //insert elmt after current elmt

  // removing the current elmt from the list
  void		RemoveCurrFromList();

  // encode and decode routines    
  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  PDU_MEMBER_MACROS
  void		Print (ostream &os) const;
};


class RDNSequence: public AsnType
{
protected:
  unsigned long int	count;
  struct AsnListElmt
  {
    AsnListElmt	*next;
    AsnListElmt	*prev;
    RelativeDistinguishedName	*elmt;
  }			*first, *curr, *last;

public:
			RDNSequence() { count = 0; first = curr = last = NULL; }
			RDNSequence (const RDNSequence &);
  virtual		~RDNSequence();
  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  RDNSequence		&operator = (const RDNSequence &);
  void		SetCurrElmt (unsigned long int index);
  unsigned long int	GetCurrElmtIndex();
  void		SetCurrToFirst() { curr = first; }
  void		SetCurrToLast()  { curr = last; }
  // reading member fcns
  int			Count() const	{ return count; }
  // NOTE: if your compiler complains about these NULLs, its definition of NULL is broken (and you better change it there!)
  RelativeDistinguishedName	*First() const	{ return count > 0 ? first->elmt : NULL; }
  RelativeDistinguishedName	*Last() const	{ return count > 0 ? last->elmt : NULL; }
  RelativeDistinguishedName	*Curr() const	{ return curr ? curr->elmt : NULL; }
  RelativeDistinguishedName	*Next() const	{ return curr && curr->next ? curr->next->elmt : NULL; }
  RelativeDistinguishedName	*Prev() const	{ return curr && curr->prev ? curr->prev->elmt : NULL; }

  // routines that move the curr elmt
  RelativeDistinguishedName	*GoNext() { if (curr) curr = curr->next; return Curr(); }
  RelativeDistinguishedName	*GoPrev() { if (curr) curr = curr->prev; return Curr(); }

  // write & alloc fcns - returns new elmt
  RelativeDistinguishedName	*Append();  // add elmt to end of list
  RelativeDistinguishedName	*Prepend(); // add elmt to beginning of list
  RelativeDistinguishedName	*InsertBefore(); //insert elmt before current elmt
  RelativeDistinguishedName	*InsertAfter(); //insert elmt after current elmt

  // write & alloc & copy - returns list after copying elmt
  RDNSequence	&AppendCopy (RelativeDistinguishedName &elmt);  // add elmt to end of list
  RDNSequence	&PrependCopy (RelativeDistinguishedName &elmt); // add elmt to beginning of list
  RDNSequence	&InsertBeforeAndCopy (RelativeDistinguishedName &elmt); //insert elmt before current elmt
  RDNSequence	&InsertAfterAndCopy (RelativeDistinguishedName &elmt); //insert elmt after current elmt

  // removing the current elmt from the list
  void		RemoveCurrFromList();

  // encode and decode routines    
  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  PDU_MEMBER_MACROS
  void		Print (ostream &os) const;
};


class Attributes: public AsnType
{
protected:
  unsigned long int	count;
  struct AsnListElmt
  {
    AsnListElmt	*next;
    AsnListElmt	*prev;
    Attribute	*elmt;
  }			*first, *curr, *last;

public:
			Attributes() { count = 0; first = curr = last = NULL; }
			Attributes (const Attributes &);
  virtual		~Attributes();
  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  Attributes		&operator = (const Attributes &);
  void		SetCurrElmt (unsigned long int index);
  unsigned long int	GetCurrElmtIndex();
  void		SetCurrToFirst() { curr = first; }
  void		SetCurrToLast()  { curr = last; }
  // reading member fcns
  int			Count() const	{ return count; }
  // NOTE: if your compiler complains about these NULLs, its definition of NULL is broken (and you better change it there!)
  Attribute	*First() const	{ return count > 0 ? first->elmt : NULL; }
  Attribute	*Last() const	{ return count > 0 ? last->elmt : NULL; }
  Attribute	*Curr() const	{ return curr ? curr->elmt : NULL; }
  Attribute	*Next() const	{ return curr && curr->next ? curr->next->elmt : NULL; }
  Attribute	*Prev() const	{ return curr && curr->prev ? curr->prev->elmt : NULL; }

  // routines that move the curr elmt
  Attribute	*GoNext() { if (curr) curr = curr->next; return Curr(); }
  Attribute	*GoPrev() { if (curr) curr = curr->prev; return Curr(); }

  // write & alloc fcns - returns new elmt
  Attribute	*Append();  // add elmt to end of list
  Attribute	*Prepend(); // add elmt to beginning of list
  Attribute	*InsertBefore(); //insert elmt before current elmt
  Attribute	*InsertAfter(); //insert elmt after current elmt

  // write & alloc & copy - returns list after copying elmt
  Attributes	&AppendCopy (Attribute &elmt);  // add elmt to end of list
  Attributes	&PrependCopy (Attribute &elmt); // add elmt to beginning of list
  Attributes	&InsertBeforeAndCopy (Attribute &elmt); //insert elmt before current elmt
  Attributes	&InsertAfterAndCopy (Attribute &elmt); //insert elmt after current elmt

  // removing the current elmt from the list
  void		RemoveCurrFromList();

  // encode and decode routines    
  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  PDU_MEMBER_MACROS
  void		Print (ostream &os) const;
};


class Name: public AsnType
{
public:
  enum ChoiceIdEnum
  {
     rDNSequenceCid = 0
  };

  enum ChoiceIdEnum	choiceId;
  union
  {
     RDNSequence		*rDNSequence;
  };


			Name();
			Name (const Name &);
  virtual		~Name();

  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  Name		&operator = (const Name &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);
  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  int			BEncPdu (BUF_TYPE b, AsnLen &bytesEncoded);
  int			BDecPdu (BUF_TYPE b, AsnLen &bytesDecoded);

  void			Print (ostream &os) const;
};


/* RDNSequence */
typedef RDNSequence DistinguishedName;

//------------------------------------------------------------------------------
// externs for value defs

//------------------------------------------------------------------------------

#endif /* conditional include of sm_x501if.h */
