//   NOTE: this is a machine generated file--editing not recommended
//
// sm_ess.h - class definitions for ASN.1 module ExtendedSecurityServices
//
//   This file was generated by snacc on Mon Apr 22 22:34:19 2002
//   UBC snacc by Mike Sample
//   A couple of enhancements made by IBM European Networking Center

#ifndef _sm_ess_h_
#define _sm_ess_h_


//------------------------------------------------------------------------------
// class declarations:

class AllOrFirstTier;
class SecurityClassification;
class SigningCertificateSeqOf1;
class MLReceiptPolicySeqOf1;
class MLReceiptPolicySeqOf;
class ReceiptsFromSeqOf;
class ReceiptRequestSeqOf;
class ESSPrivacyMark;
class SecurityCategory;
class EntityIdentifier;
class ReceiptsFrom;
class SecurityCategories;
class MLReceiptPolicy;
class ESSCertID;
class SigningCertificateSeqOf;
class ESSSecurityLabel;
class MLData;
class ReceiptRequest;
class Receipt;
class ContentHints;
class ContentReference;
class EquivalentLabels;
class MLExpansionHistory;
class SigningCertificate;

//------------------------------------------------------------------------------
// class definitions:

typedef enum ExtendedSecurityServicesAnyId
{

} ExtendedSecurityServicesAnyId;


/* OCTET STRING */
typedef AsnOcts ContentIdentifier;

/* INTEGER { allReceipts (0), firstTierRecipients (1) }  */
class AllOrFirstTier: public AsnInt
{
public:
			AllOrFirstTier(): AsnInt() {}
			AllOrFirstTier (int i): AsnInt (i) {}
  enum
  {
    allReceipts = 0,
    firstTierRecipients = 1
  };
};


/* OCTET STRING */
typedef AsnOcts MsgSigDigest;

/* OBJECT IDENTIFIER */
typedef AsnOid SecurityPolicyIdentifier;

/* INTEGER { unmarked (0), unclassified (1), restricted (2), confidential (3), secret (4), top_secret (5) }  (0..ub-integer-options) */
class SecurityClassification: public AsnInt
{
public:
			SecurityClassification(): AsnInt() {}
			SecurityClassification (int i): AsnInt (i) {}
  enum
  {
    unmarked = 0,
    unclassified = 1,
    restricted = 2,
    confidential = 3,
    secret = 4,
    top_secret = 5
  };
};


/* OCTET STRING */
typedef AsnOcts CertHash;

/* OBJECT IDENTIFIER (id-qt-cps) | (id-qt-unotice) */
typedef AsnOid PolicyQualifierId;

class SigningCertificateSeqOf1: public AsnType
{
protected:
  unsigned long int	count;
  struct AsnListElmt
  {
    AsnListElmt	*next;
    AsnListElmt	*prev;
    PolicyInformation	*elmt;
  }			*first, *curr, *last;

public:
			SigningCertificateSeqOf1() { count = 0; first = curr = last = NULL; }
			SigningCertificateSeqOf1 (const SigningCertificateSeqOf1 &);
  virtual		~SigningCertificateSeqOf1();
  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  SigningCertificateSeqOf1		&operator = (const SigningCertificateSeqOf1 &);
  void		SetCurrElmt (unsigned long int index);
  unsigned long int	GetCurrElmtIndex();
  void		SetCurrToFirst() { curr = first; }
  void		SetCurrToLast()  { curr = last; }
  // reading member fcns
  int			Count() const	{ return count; }
  // NOTE: if your compiler complains about these NULLs, its definition of NULL is broken (and you better change it there!)
  PolicyInformation	*First() const	{ return count > 0 ? first->elmt : NULL; }
  PolicyInformation	*Last() const	{ return count > 0 ? last->elmt : NULL; }
  PolicyInformation	*Curr() const	{ return curr ? curr->elmt : NULL; }
  PolicyInformation	*Next() const	{ return curr && curr->next ? curr->next->elmt : NULL; }
  PolicyInformation	*Prev() const	{ return curr && curr->prev ? curr->prev->elmt : NULL; }

  // routines that move the curr elmt
  PolicyInformation	*GoNext() { if (curr) curr = curr->next; return Curr(); }
  PolicyInformation	*GoPrev() { if (curr) curr = curr->prev; return Curr(); }

  // write & alloc fcns - returns new elmt
  PolicyInformation	*Append();  // add elmt to end of list
  PolicyInformation	*Prepend(); // add elmt to beginning of list
  PolicyInformation	*InsertBefore(); //insert elmt before current elmt
  PolicyInformation	*InsertAfter(); //insert elmt after current elmt

  // write & alloc & copy - returns list after copying elmt
  SigningCertificateSeqOf1	&AppendCopy (PolicyInformation &elmt);  // add elmt to end of list
  SigningCertificateSeqOf1	&PrependCopy (PolicyInformation &elmt); // add elmt to beginning of list
  SigningCertificateSeqOf1	&InsertBeforeAndCopy (PolicyInformation &elmt); //insert elmt before current elmt
  SigningCertificateSeqOf1	&InsertAfterAndCopy (PolicyInformation &elmt); //insert elmt after current elmt

  // removing the current elmt from the list
  void		RemoveCurrFromList();

  // encode and decode routines    
  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  PDU_MEMBER_MACROS
  void		Print (ostream &os) const;
};


class MLReceiptPolicySeqOf1: public AsnType
{
protected:
  unsigned long int	count;
  struct AsnListElmt
  {
    AsnListElmt	*next;
    AsnListElmt	*prev;
    GeneralNames	*elmt;
  }			*first, *curr, *last;

public:
			MLReceiptPolicySeqOf1() { count = 0; first = curr = last = NULL; }
			MLReceiptPolicySeqOf1 (const MLReceiptPolicySeqOf1 &);
  virtual		~MLReceiptPolicySeqOf1();
  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  MLReceiptPolicySeqOf1		&operator = (const MLReceiptPolicySeqOf1 &);
  void		SetCurrElmt (unsigned long int index);
  unsigned long int	GetCurrElmtIndex();
  void		SetCurrToFirst() { curr = first; }
  void		SetCurrToLast()  { curr = last; }
  // reading member fcns
  int			Count() const	{ return count; }
  // NOTE: if your compiler complains about these NULLs, its definition of NULL is broken (and you better change it there!)
  GeneralNames	*First() const	{ return count > 0 ? first->elmt : NULL; }
  GeneralNames	*Last() const	{ return count > 0 ? last->elmt : NULL; }
  GeneralNames	*Curr() const	{ return curr ? curr->elmt : NULL; }
  GeneralNames	*Next() const	{ return curr && curr->next ? curr->next->elmt : NULL; }
  GeneralNames	*Prev() const	{ return curr && curr->prev ? curr->prev->elmt : NULL; }

  // routines that move the curr elmt
  GeneralNames	*GoNext() { if (curr) curr = curr->next; return Curr(); }
  GeneralNames	*GoPrev() { if (curr) curr = curr->prev; return Curr(); }

  // write & alloc fcns - returns new elmt
  GeneralNames	*Append();  // add elmt to end of list
  GeneralNames	*Prepend(); // add elmt to beginning of list
  GeneralNames	*InsertBefore(); //insert elmt before current elmt
  GeneralNames	*InsertAfter(); //insert elmt after current elmt

  // write & alloc & copy - returns list after copying elmt
  MLReceiptPolicySeqOf1	&AppendCopy (GeneralNames &elmt);  // add elmt to end of list
  MLReceiptPolicySeqOf1	&PrependCopy (GeneralNames &elmt); // add elmt to beginning of list
  MLReceiptPolicySeqOf1	&InsertBeforeAndCopy (GeneralNames &elmt); //insert elmt before current elmt
  MLReceiptPolicySeqOf1	&InsertAfterAndCopy (GeneralNames &elmt); //insert elmt after current elmt

  // removing the current elmt from the list
  void		RemoveCurrFromList();

  // encode and decode routines    
  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  PDU_MEMBER_MACROS
  void		Print (ostream &os) const;
};


class MLReceiptPolicySeqOf: public AsnType
{
protected:
  unsigned long int	count;
  struct AsnListElmt
  {
    AsnListElmt	*next;
    AsnListElmt	*prev;
    GeneralNames	*elmt;
  }			*first, *curr, *last;

public:
			MLReceiptPolicySeqOf() { count = 0; first = curr = last = NULL; }
			MLReceiptPolicySeqOf (const MLReceiptPolicySeqOf &);
  virtual		~MLReceiptPolicySeqOf();
  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  MLReceiptPolicySeqOf		&operator = (const MLReceiptPolicySeqOf &);
  void		SetCurrElmt (unsigned long int index);
  unsigned long int	GetCurrElmtIndex();
  void		SetCurrToFirst() { curr = first; }
  void		SetCurrToLast()  { curr = last; }
  // reading member fcns
  int			Count() const	{ return count; }
  // NOTE: if your compiler complains about these NULLs, its definition of NULL is broken (and you better change it there!)
  GeneralNames	*First() const	{ return count > 0 ? first->elmt : NULL; }
  GeneralNames	*Last() const	{ return count > 0 ? last->elmt : NULL; }
  GeneralNames	*Curr() const	{ return curr ? curr->elmt : NULL; }
  GeneralNames	*Next() const	{ return curr && curr->next ? curr->next->elmt : NULL; }
  GeneralNames	*Prev() const	{ return curr && curr->prev ? curr->prev->elmt : NULL; }

  // routines that move the curr elmt
  GeneralNames	*GoNext() { if (curr) curr = curr->next; return Curr(); }
  GeneralNames	*GoPrev() { if (curr) curr = curr->prev; return Curr(); }

  // write & alloc fcns - returns new elmt
  GeneralNames	*Append();  // add elmt to end of list
  GeneralNames	*Prepend(); // add elmt to beginning of list
  GeneralNames	*InsertBefore(); //insert elmt before current elmt
  GeneralNames	*InsertAfter(); //insert elmt after current elmt

  // write & alloc & copy - returns list after copying elmt
  MLReceiptPolicySeqOf	&AppendCopy (GeneralNames &elmt);  // add elmt to end of list
  MLReceiptPolicySeqOf	&PrependCopy (GeneralNames &elmt); // add elmt to beginning of list
  MLReceiptPolicySeqOf	&InsertBeforeAndCopy (GeneralNames &elmt); //insert elmt before current elmt
  MLReceiptPolicySeqOf	&InsertAfterAndCopy (GeneralNames &elmt); //insert elmt after current elmt

  // removing the current elmt from the list
  void		RemoveCurrFromList();

  // encode and decode routines    
  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  PDU_MEMBER_MACROS
  void		Print (ostream &os) const;
};


class ReceiptsFromSeqOf: public AsnType
{
protected:
  unsigned long int	count;
  struct AsnListElmt
  {
    AsnListElmt	*next;
    AsnListElmt	*prev;
    GeneralNames	*elmt;
  }			*first, *curr, *last;

public:
			ReceiptsFromSeqOf() { count = 0; first = curr = last = NULL; }
			ReceiptsFromSeqOf (const ReceiptsFromSeqOf &);
  virtual		~ReceiptsFromSeqOf();
  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  ReceiptsFromSeqOf		&operator = (const ReceiptsFromSeqOf &);
  void		SetCurrElmt (unsigned long int index);
  unsigned long int	GetCurrElmtIndex();
  void		SetCurrToFirst() { curr = first; }
  void		SetCurrToLast()  { curr = last; }
  // reading member fcns
  int			Count() const	{ return count; }
  // NOTE: if your compiler complains about these NULLs, its definition of NULL is broken (and you better change it there!)
  GeneralNames	*First() const	{ return count > 0 ? first->elmt : NULL; }
  GeneralNames	*Last() const	{ return count > 0 ? last->elmt : NULL; }
  GeneralNames	*Curr() const	{ return curr ? curr->elmt : NULL; }
  GeneralNames	*Next() const	{ return curr && curr->next ? curr->next->elmt : NULL; }
  GeneralNames	*Prev() const	{ return curr && curr->prev ? curr->prev->elmt : NULL; }

  // routines that move the curr elmt
  GeneralNames	*GoNext() { if (curr) curr = curr->next; return Curr(); }
  GeneralNames	*GoPrev() { if (curr) curr = curr->prev; return Curr(); }

  // write & alloc fcns - returns new elmt
  GeneralNames	*Append();  // add elmt to end of list
  GeneralNames	*Prepend(); // add elmt to beginning of list
  GeneralNames	*InsertBefore(); //insert elmt before current elmt
  GeneralNames	*InsertAfter(); //insert elmt after current elmt

  // write & alloc & copy - returns list after copying elmt
  ReceiptsFromSeqOf	&AppendCopy (GeneralNames &elmt);  // add elmt to end of list
  ReceiptsFromSeqOf	&PrependCopy (GeneralNames &elmt); // add elmt to beginning of list
  ReceiptsFromSeqOf	&InsertBeforeAndCopy (GeneralNames &elmt); //insert elmt before current elmt
  ReceiptsFromSeqOf	&InsertAfterAndCopy (GeneralNames &elmt); //insert elmt after current elmt

  // removing the current elmt from the list
  void		RemoveCurrFromList();

  // encode and decode routines    
  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  PDU_MEMBER_MACROS
  void		Print (ostream &os) const;
};


class ReceiptRequestSeqOf: public AsnType
{
protected:
  unsigned long int	count;
  struct AsnListElmt
  {
    AsnListElmt	*next;
    AsnListElmt	*prev;
    GeneralNames	*elmt;
  }			*first, *curr, *last;

public:
			ReceiptRequestSeqOf() { count = 0; first = curr = last = NULL; }
			ReceiptRequestSeqOf (const ReceiptRequestSeqOf &);
  virtual		~ReceiptRequestSeqOf();
  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  ReceiptRequestSeqOf		&operator = (const ReceiptRequestSeqOf &);
  void		SetCurrElmt (unsigned long int index);
  unsigned long int	GetCurrElmtIndex();
  void		SetCurrToFirst() { curr = first; }
  void		SetCurrToLast()  { curr = last; }
  // reading member fcns
  int			Count() const	{ return count; }
  // NOTE: if your compiler complains about these NULLs, its definition of NULL is broken (and you better change it there!)
  GeneralNames	*First() const	{ return count > 0 ? first->elmt : NULL; }
  GeneralNames	*Last() const	{ return count > 0 ? last->elmt : NULL; }
  GeneralNames	*Curr() const	{ return curr ? curr->elmt : NULL; }
  GeneralNames	*Next() const	{ return curr && curr->next ? curr->next->elmt : NULL; }
  GeneralNames	*Prev() const	{ return curr && curr->prev ? curr->prev->elmt : NULL; }

  // routines that move the curr elmt
  GeneralNames	*GoNext() { if (curr) curr = curr->next; return Curr(); }
  GeneralNames	*GoPrev() { if (curr) curr = curr->prev; return Curr(); }

  // write & alloc fcns - returns new elmt
  GeneralNames	*Append();  // add elmt to end of list
  GeneralNames	*Prepend(); // add elmt to beginning of list
  GeneralNames	*InsertBefore(); //insert elmt before current elmt
  GeneralNames	*InsertAfter(); //insert elmt after current elmt

  // write & alloc & copy - returns list after copying elmt
  ReceiptRequestSeqOf	&AppendCopy (GeneralNames &elmt);  // add elmt to end of list
  ReceiptRequestSeqOf	&PrependCopy (GeneralNames &elmt); // add elmt to beginning of list
  ReceiptRequestSeqOf	&InsertBeforeAndCopy (GeneralNames &elmt); //insert elmt before current elmt
  ReceiptRequestSeqOf	&InsertAfterAndCopy (GeneralNames &elmt); //insert elmt after current elmt

  // removing the current elmt from the list
  void		RemoveCurrFromList();

  // encode and decode routines    
  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  PDU_MEMBER_MACROS
  void		Print (ostream &os) const;
};


class ESSPrivacyMark: public AsnType
{
public:
  enum ChoiceIdEnum
  {
     pStringCid = 0,
     utf8StringCid = 1
  };

  enum ChoiceIdEnum	choiceId;
  union
  {
     PrintableString		*pString;
     UTF8String		*utf8String;
  };


			ESSPrivacyMark();
			ESSPrivacyMark (const ESSPrivacyMark &);
  virtual		~ESSPrivacyMark();

  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  ESSPrivacyMark		&operator = (const ESSPrivacyMark &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);
  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  void			Print (ostream &os) const;
};


class SecurityCategory: public AsnType
{
public:
  AsnOid		type;
  AsnAny		value;

			SecurityCategory();
			SecurityCategory (const SecurityCategory &);
  virtual		~SecurityCategory();
  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  SecurityCategory		&operator = (const SecurityCategory &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  void		Print (ostream &os) const;
};


class EntityIdentifier: public AsnType
{
public:
  enum ChoiceIdEnum
  {
     issuerAndSerialNumberCid = 0,
     subjectKeyIdentifierCid = 1
  };

  enum ChoiceIdEnum	choiceId;
  union
  {
     IssuerAndSerialNumber		*issuerAndSerialNumber;
     KeyIdentifier		*subjectKeyIdentifier;
  };


			EntityIdentifier();
			EntityIdentifier (const EntityIdentifier &);
  virtual		~EntityIdentifier();

  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  EntityIdentifier		&operator = (const EntityIdentifier &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);
  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  void			Print (ostream &os) const;
};


class ReceiptsFrom: public AsnType
{
public:
  enum ChoiceIdEnum
  {
     allOrFirstTierCid = 0,
     receiptListCid = 1
  };

  enum ChoiceIdEnum	choiceId;
  union
  {
     AllOrFirstTier		*allOrFirstTier;
     ReceiptsFromSeqOf		*receiptList;
  };


			ReceiptsFrom();
			ReceiptsFrom (const ReceiptsFrom &);
  virtual		~ReceiptsFrom();

  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  ReceiptsFrom		&operator = (const ReceiptsFrom &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);
  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  void			Print (ostream &os) const;
};


class SecurityCategories: public AsnType
{
protected:
  unsigned long int	count;
  struct AsnListElmt
  {
    AsnListElmt	*next;
    AsnListElmt	*prev;
    SecurityCategory	*elmt;
  }			*first, *curr, *last;

public:
			SecurityCategories() { count = 0; first = curr = last = NULL; }
			SecurityCategories (const SecurityCategories &);
  virtual		~SecurityCategories();
  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  SecurityCategories		&operator = (const SecurityCategories &);
  void		SetCurrElmt (unsigned long int index);
  unsigned long int	GetCurrElmtIndex();
  void		SetCurrToFirst() { curr = first; }
  void		SetCurrToLast()  { curr = last; }
  // reading member fcns
  int			Count() const	{ return count; }
  // NOTE: if your compiler complains about these NULLs, its definition of NULL is broken (and you better change it there!)
  SecurityCategory	*First() const	{ return count > 0 ? first->elmt : NULL; }
  SecurityCategory	*Last() const	{ return count > 0 ? last->elmt : NULL; }
  SecurityCategory	*Curr() const	{ return curr ? curr->elmt : NULL; }
  SecurityCategory	*Next() const	{ return curr && curr->next ? curr->next->elmt : NULL; }
  SecurityCategory	*Prev() const	{ return curr && curr->prev ? curr->prev->elmt : NULL; }

  // routines that move the curr elmt
  SecurityCategory	*GoNext() { if (curr) curr = curr->next; return Curr(); }
  SecurityCategory	*GoPrev() { if (curr) curr = curr->prev; return Curr(); }

  // write & alloc fcns - returns new elmt
  SecurityCategory	*Append();  // add elmt to end of list
  SecurityCategory	*Prepend(); // add elmt to beginning of list
  SecurityCategory	*InsertBefore(); //insert elmt before current elmt
  SecurityCategory	*InsertAfter(); //insert elmt after current elmt

  // write & alloc & copy - returns list after copying elmt
  SecurityCategories	&AppendCopy (SecurityCategory &elmt);  // add elmt to end of list
  SecurityCategories	&PrependCopy (SecurityCategory &elmt); // add elmt to beginning of list
  SecurityCategories	&InsertBeforeAndCopy (SecurityCategory &elmt); //insert elmt before current elmt
  SecurityCategories	&InsertAfterAndCopy (SecurityCategory &elmt); //insert elmt after current elmt

  // removing the current elmt from the list
  void		RemoveCurrFromList();

  // encode and decode routines    
  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  PDU_MEMBER_MACROS
  void		Print (ostream &os) const;
};


class MLReceiptPolicy: public AsnType
{
public:
  enum ChoiceIdEnum
  {
     noneCid = 0,
     insteadOfCid = 1,
     inAdditionToCid = 2
  };

  enum ChoiceIdEnum	choiceId;
  union
  {
     AsnNull		*none;
     MLReceiptPolicySeqOf		*insteadOf;
     MLReceiptPolicySeqOf1		*inAdditionTo;
  };


			MLReceiptPolicy();
			MLReceiptPolicy (const MLReceiptPolicy &);
  virtual		~MLReceiptPolicy();

  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  MLReceiptPolicy		&operator = (const MLReceiptPolicy &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);
  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  void			Print (ostream &os) const;
};


class ESSCertID: public AsnType
{
public:
  CertHash		certHash;
  IssuerSerial		*issuerSerial;

			ESSCertID();
			ESSCertID (const ESSCertID &);
  virtual		~ESSCertID();
  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  ESSCertID		&operator = (const ESSCertID &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  void		Print (ostream &os) const;
};


class SigningCertificateSeqOf: public AsnType
{
protected:
  unsigned long int	count;
  struct AsnListElmt
  {
    AsnListElmt	*next;
    AsnListElmt	*prev;
    ESSCertID	*elmt;
  }			*first, *curr, *last;

public:
			SigningCertificateSeqOf() { count = 0; first = curr = last = NULL; }
			SigningCertificateSeqOf (const SigningCertificateSeqOf &);
  virtual		~SigningCertificateSeqOf();
  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  SigningCertificateSeqOf		&operator = (const SigningCertificateSeqOf &);
  void		SetCurrElmt (unsigned long int index);
  unsigned long int	GetCurrElmtIndex();
  void		SetCurrToFirst() { curr = first; }
  void		SetCurrToLast()  { curr = last; }
  // reading member fcns
  int			Count() const	{ return count; }
  // NOTE: if your compiler complains about these NULLs, its definition of NULL is broken (and you better change it there!)
  ESSCertID	*First() const	{ return count > 0 ? first->elmt : NULL; }
  ESSCertID	*Last() const	{ return count > 0 ? last->elmt : NULL; }
  ESSCertID	*Curr() const	{ return curr ? curr->elmt : NULL; }
  ESSCertID	*Next() const	{ return curr && curr->next ? curr->next->elmt : NULL; }
  ESSCertID	*Prev() const	{ return curr && curr->prev ? curr->prev->elmt : NULL; }

  // routines that move the curr elmt
  ESSCertID	*GoNext() { if (curr) curr = curr->next; return Curr(); }
  ESSCertID	*GoPrev() { if (curr) curr = curr->prev; return Curr(); }

  // write & alloc fcns - returns new elmt
  ESSCertID	*Append();  // add elmt to end of list
  ESSCertID	*Prepend(); // add elmt to beginning of list
  ESSCertID	*InsertBefore(); //insert elmt before current elmt
  ESSCertID	*InsertAfter(); //insert elmt after current elmt

  // write & alloc & copy - returns list after copying elmt
  SigningCertificateSeqOf	&AppendCopy (ESSCertID &elmt);  // add elmt to end of list
  SigningCertificateSeqOf	&PrependCopy (ESSCertID &elmt); // add elmt to beginning of list
  SigningCertificateSeqOf	&InsertBeforeAndCopy (ESSCertID &elmt); //insert elmt before current elmt
  SigningCertificateSeqOf	&InsertAfterAndCopy (ESSCertID &elmt); //insert elmt after current elmt

  // removing the current elmt from the list
  void		RemoveCurrFromList();

  // encode and decode routines    
  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  PDU_MEMBER_MACROS
  void		Print (ostream &os) const;
};


class ESSSecurityLabel: public AsnType
{
public:
  SecurityPolicyIdentifier		security_policy_identifier;
  SecurityClassification		*security_classification;
  ESSPrivacyMark		*privacy_mark;
  SecurityCategories		*security_categories;

			ESSSecurityLabel();
			ESSSecurityLabel (const ESSSecurityLabel &);
  virtual		~ESSSecurityLabel();
  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  ESSSecurityLabel		&operator = (const ESSSecurityLabel &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  void			Print (ostream &os) const;
};


class MLData: public AsnType
{
public:
  EntityIdentifier		*mailListIdentifier;
  GeneralizedTime		expansionTime;
  MLReceiptPolicy		*mlReceiptPolicy;

			MLData();
			MLData (const MLData &);
  virtual		~MLData();
  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  MLData		&operator = (const MLData &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  void		Print (ostream &os) const;
};


class ReceiptRequest: public AsnType
{
public:
  ContentIdentifier		signedContentIdentifier;
  ReceiptsFrom		*receiptsFrom;
  ReceiptRequestSeqOf		receiptsTo;

			ReceiptRequest();
			ReceiptRequest (const ReceiptRequest &);
  virtual		~ReceiptRequest();
  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  ReceiptRequest		&operator = (const ReceiptRequest &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  void		Print (ostream &os) const;
};


class Receipt: public AsnType
{
public:
  CMSVersion		version;
  ContentType		contentType;
  ContentIdentifier		signedContentIdentifier;
  AsnOcts		originatorSignatureValue;

			Receipt();
			Receipt (const Receipt &);
  virtual		~Receipt();
  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  Receipt		&operator = (const Receipt &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  void		Print (ostream &os) const;
};


class ContentHints: public AsnType
{
public:
  UTF8String		*contentDescription;
  ContentType		contentType;

			ContentHints();
			ContentHints (const ContentHints &);
  virtual		~ContentHints();
  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  ContentHints		&operator = (const ContentHints &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  void		Print (ostream &os) const;
};


class ContentReference: public AsnType
{
public:
  ContentType		contentType;
  ContentIdentifier		signedContentIdentifier;
  AsnOcts		originatorSignatureValue;

			ContentReference();
			ContentReference (const ContentReference &);
  virtual		~ContentReference();
  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  ContentReference		&operator = (const ContentReference &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  void		Print (ostream &os) const;
};


class EquivalentLabels: public AsnType
{
protected:
  unsigned long int	count;
  struct AsnListElmt
  {
    AsnListElmt	*next;
    AsnListElmt	*prev;
    ESSSecurityLabel	*elmt;
  }			*first, *curr, *last;

public:
			EquivalentLabels() { count = 0; first = curr = last = NULL; }
			EquivalentLabels (const EquivalentLabels &);
  virtual		~EquivalentLabels();
  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  EquivalentLabels		&operator = (const EquivalentLabels &);
  void		SetCurrElmt (unsigned long int index);
  unsigned long int	GetCurrElmtIndex();
  void		SetCurrToFirst() { curr = first; }
  void		SetCurrToLast()  { curr = last; }
  // reading member fcns
  int			Count() const	{ return count; }
  // NOTE: if your compiler complains about these NULLs, its definition of NULL is broken (and you better change it there!)
  ESSSecurityLabel	*First() const	{ return count > 0 ? first->elmt : NULL; }
  ESSSecurityLabel	*Last() const	{ return count > 0 ? last->elmt : NULL; }
  ESSSecurityLabel	*Curr() const	{ return curr ? curr->elmt : NULL; }
  ESSSecurityLabel	*Next() const	{ return curr && curr->next ? curr->next->elmt : NULL; }
  ESSSecurityLabel	*Prev() const	{ return curr && curr->prev ? curr->prev->elmt : NULL; }

  // routines that move the curr elmt
  ESSSecurityLabel	*GoNext() { if (curr) curr = curr->next; return Curr(); }
  ESSSecurityLabel	*GoPrev() { if (curr) curr = curr->prev; return Curr(); }

  // write & alloc fcns - returns new elmt
  ESSSecurityLabel	*Append();  // add elmt to end of list
  ESSSecurityLabel	*Prepend(); // add elmt to beginning of list
  ESSSecurityLabel	*InsertBefore(); //insert elmt before current elmt
  ESSSecurityLabel	*InsertAfter(); //insert elmt after current elmt

  // write & alloc & copy - returns list after copying elmt
  EquivalentLabels	&AppendCopy (ESSSecurityLabel &elmt);  // add elmt to end of list
  EquivalentLabels	&PrependCopy (ESSSecurityLabel &elmt); // add elmt to beginning of list
  EquivalentLabels	&InsertBeforeAndCopy (ESSSecurityLabel &elmt); //insert elmt before current elmt
  EquivalentLabels	&InsertAfterAndCopy (ESSSecurityLabel &elmt); //insert elmt after current elmt

  // removing the current elmt from the list
  void		RemoveCurrFromList();

  // encode and decode routines    
  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  PDU_MEMBER_MACROS
  void		Print (ostream &os) const;
};


class MLExpansionHistory: public AsnType
{
protected:
  unsigned long int	count;
  struct AsnListElmt
  {
    AsnListElmt	*next;
    AsnListElmt	*prev;
    MLData	*elmt;
  }			*first, *curr, *last;

public:
			MLExpansionHistory() { count = 0; first = curr = last = NULL; }
			MLExpansionHistory (const MLExpansionHistory &);
  virtual		~MLExpansionHistory();
  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  MLExpansionHistory		&operator = (const MLExpansionHistory &);
  void		SetCurrElmt (unsigned long int index);
  unsigned long int	GetCurrElmtIndex();
  void		SetCurrToFirst() { curr = first; }
  void		SetCurrToLast()  { curr = last; }
  // reading member fcns
  int			Count() const	{ return count; }
  // NOTE: if your compiler complains about these NULLs, its definition of NULL is broken (and you better change it there!)
  MLData	*First() const	{ return count > 0 ? first->elmt : NULL; }
  MLData	*Last() const	{ return count > 0 ? last->elmt : NULL; }
  MLData	*Curr() const	{ return curr ? curr->elmt : NULL; }
  MLData	*Next() const	{ return curr && curr->next ? curr->next->elmt : NULL; }
  MLData	*Prev() const	{ return curr && curr->prev ? curr->prev->elmt : NULL; }

  // routines that move the curr elmt
  MLData	*GoNext() { if (curr) curr = curr->next; return Curr(); }
  MLData	*GoPrev() { if (curr) curr = curr->prev; return Curr(); }

  // write & alloc fcns - returns new elmt
  MLData	*Append();  // add elmt to end of list
  MLData	*Prepend(); // add elmt to beginning of list
  MLData	*InsertBefore(); //insert elmt before current elmt
  MLData	*InsertAfter(); //insert elmt after current elmt

  // write & alloc & copy - returns list after copying elmt
  MLExpansionHistory	&AppendCopy (MLData &elmt);  // add elmt to end of list
  MLExpansionHistory	&PrependCopy (MLData &elmt); // add elmt to beginning of list
  MLExpansionHistory	&InsertBeforeAndCopy (MLData &elmt); //insert elmt before current elmt
  MLExpansionHistory	&InsertAfterAndCopy (MLData &elmt); //insert elmt after current elmt

  // removing the current elmt from the list
  void		RemoveCurrFromList();

  // encode and decode routines    
  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  PDU_MEMBER_MACROS
  void		Print (ostream &os) const;
};


class SigningCertificate: public AsnType
{
public:
  SigningCertificateSeqOf		certs;
  SigningCertificateSeqOf1		*policies;

			SigningCertificate();
			SigningCertificate (const SigningCertificate &);
  virtual		~SigningCertificate();
  virtual AsnType	*Clone() const;

  virtual AsnType	*Copy() const;

  SigningCertificate		&operator = (const SigningCertificate &);
  AsnLen		BEncContent (BUF_TYPE b);
  void			BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen, AsnLen &bytesDecoded, ENV_TYPE env);

  AsnLen		BEnc (BUF_TYPE b);
  void			BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env);
  void		Print (ostream &os) const;
};


//------------------------------------------------------------------------------
// externs for value defs

#define ub_receiptsTo_val 16
#define ub_receiptsTo     AsnInt(ub_receiptsTo_val)
#define smime_arc 1, 2, 840, 113549, 1, 9, 16
#define smime     AsnOid(smime_arc)
#define id_aa_arc 1, 2, 840, 113549, 1, 9, 16, 2
#define id_aa     AsnOid(id_aa_arc)
#define id_aa_receiptRequest_arc 1, 2, 840, 113549, 1, 9, 16, 2, 1
#define id_aa_receiptRequest     AsnOid(id_aa_receiptRequest_arc)
#define id_aa_contentIdentifier_arc 1, 2, 840, 113549, 1, 9, 16, 2, 7
#define id_aa_contentIdentifier     AsnOid(id_aa_contentIdentifier_arc)
#define id_ct_receipt_arc 1, 2, 840, 113549, 1, 9, 16, 1, 1
#define id_ct_receipt     AsnOid(id_ct_receipt_arc)
#define id_aa_contentHint_arc 1, 2, 840, 113549, 1, 9, 16, 2, 4
#define id_aa_contentHint     AsnOid(id_aa_contentHint_arc)
#define id_aa_msgSigDigest_arc 1, 2, 840, 113549, 1, 9, 16, 2, 5
#define id_aa_msgSigDigest     AsnOid(id_aa_msgSigDigest_arc)
#define id_aa_contentReference_arc 1, 2, 840, 113549, 1, 9, 16, 2, 10
#define id_aa_contentReference     AsnOid(id_aa_contentReference_arc)
#define id_aa_securityLabel_arc 1, 2, 840, 113549, 1, 9, 16, 2, 2
#define id_aa_securityLabel     AsnOid(id_aa_securityLabel_arc)
#define id_aa_equivalentLabels_arc 1, 2, 840, 113549, 1, 9, 16, 2, 9
#define id_aa_equivalentLabels     AsnOid(id_aa_equivalentLabels_arc)
#define id_aa_mlExpandHistory_arc 1, 2, 840, 113549, 1, 9, 16, 2, 3
#define id_aa_mlExpandHistory     AsnOid(id_aa_mlExpandHistory_arc)
#define ub_ml_expansion_history_val 64
#define ub_ml_expansion_history     AsnInt(ub_ml_expansion_history_val)
#define id_aa_signingCertificate_arc 1, 2, 840, 113549, 1, 9, 16, 2, 4444
#define id_aa_signingCertificate     AsnOid(id_aa_signingCertificate_arc)
#define id_pkix_arc 1, 3, 6, 1, 5, 5, 7
#define id_pkix     AsnOid(id_pkix_arc)
#define id_qt_arc 1, 3, 6, 1, 5, 5, 7, 2
#define id_qt     AsnOid(id_qt_arc)
#define id_qt_cps_arc 1, 3, 6, 1, 5, 5, 7, 2, 1
#define id_qt_cps     AsnOid(id_qt_cps_arc)
#define id_qt_unotice_arc 1, 3, 6, 1, 5, 5, 7, 2, 2
#define id_qt_unotice     AsnOid(id_qt_unotice_arc)
//------------------------------------------------------------------------------

#endif /* conditional include of sm_ess.h */
