//   NOTE: this is a machine generated file--editing not recommended
//
// pkcs7.cpp - class member functions for ASN.1 module PKCS7
//
//   This file was generated by snacc on Mon Apr 22 22:34:19 2002
//   UBC snacc written by Mike Sample
//   A couple of enhancements made by IBM European Networking Center


#include "asn-incl.h"
#include "sm_vdatypes.h"
#include "sm_x501ud.h"
#include "sm_x411ub.h"
#include "sm_x411mtsas.h"
#include "sm_x501if.h"
#include "sm_x520sa.h"
#include "sm_x509cmn.h"
#include "sm_x509af.h"
#include "sm_x509ce.h"
#include "pkcs1oids.h"
#include "pkcs9oids.h"
#include "sm_cms.h"
#include "sm_ess.h"
#include "pkcs7.h"
#include "pkcs8.h"
#include "appleoids.h"
#include "pkcs10.h"

//------------------------------------------------------------------------------
// value defs


//------------------------------------------------------------------------------
// class member definitions:

EncryptedContentInfo1::EncryptedContentInfo1()
{
#if TCL
  contentEncryptionAlgorithm = new ContentEncryptionAlgorithmIdentifier1;
#else
  contentEncryptionAlgorithm = NULL; // incomplete initialization of mandatory element!
#endif // TCL
  encryptedContent = NULL;
}

EncryptedContentInfo1::EncryptedContentInfo1 (const EncryptedContentInfo1 &)
{
  Asn1Error << "use of incompletely defined EncryptedContentInfo1::EncryptedContentInfo1 (const EncryptedContentInfo1 &)" << endl;
  abort();
}

EncryptedContentInfo1::~EncryptedContentInfo1()
{
  delete contentEncryptionAlgorithm;
  delete encryptedContent;
}

AsnType *EncryptedContentInfo1::Clone() const
{
  return new EncryptedContentInfo1;
}

AsnType *EncryptedContentInfo1::Copy() const
{
  return new EncryptedContentInfo1 (*this);
}

#if SNACC_DEEP_COPY
EncryptedContentInfo1 &EncryptedContentInfo1::operator = (const EncryptedContentInfo1 &that)
#else // SNACC_DEEP_COPY
EncryptedContentInfo1 &EncryptedContentInfo1::operator = (const EncryptedContentInfo1 &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    contentType = that.contentType;
    if (that.contentEncryptionAlgorithm)
    {
      if (!contentEncryptionAlgorithm)
        contentEncryptionAlgorithm = new ContentEncryptionAlgorithmIdentifier1;
      *contentEncryptionAlgorithm = *that.contentEncryptionAlgorithm;
    }
    else
    {
      delete contentEncryptionAlgorithm;
      contentEncryptionAlgorithm = NULL;
    }
    if (that.encryptedContent)
    {
      if (!encryptedContent)
        encryptedContent = new EncryptedContent1;
      *encryptedContent = *that.encryptedContent;
    }
    else
    {
      delete encryptedContent;
      encryptedContent = NULL;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined EncryptedContentInfo1 &EncryptedContentInfo1::operator = (const EncryptedContentInfo1 &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
EncryptedContentInfo1::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

  if (NOT_NULL (encryptedContent))
  {
    l = encryptedContent->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 0);
    totalLen += l;
  }

      BEncEocIfNec (b);
    l = contentEncryptionAlgorithm->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;

    l = contentType.BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, UNIV, PRIM, OID_TAG_CODE);
    totalLen += l;

  return totalLen;
} // EncryptedContentInfo1::BEncContent


void EncryptedContentInfo1::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, OID_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    contentType.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    SnaccExcep::throwMe(-100);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    contentEncryptionAlgorithm = new ContentEncryptionAlgorithmIdentifier1;
    contentEncryptionAlgorithm->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    SnaccExcep::throwMe(-101);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    encryptedContent = new EncryptedContent1;
    encryptedContent->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << endl;
    SnaccExcep::throwMe(-102);
  }
  else
    return;
} // EncryptedContentInfo1::BDecContent

AsnLen EncryptedContentInfo1::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void EncryptedContentInfo1::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "EncryptedContentInfo1::BDec: ERROR - wrong tag" << endl;
    SnaccExcep::throwMe(-103);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

void EncryptedContentInfo1::Print (ostream &os) const
{
#ifndef NDEBUG
  os << "{ -- SEQUENCE --" << endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "contentType ";
    os << contentType;
    os << "," << endl;
  }

  if (NOT_NULL (contentEncryptionAlgorithm))
  {
    Indent (os, indentG);
    os << "contentEncryptionAlgorithm ";
    os << *contentEncryptionAlgorithm;
  }
  else
  {
    Indent (os, indentG);
    os << "contentEncryptionAlgorithm ";
    os << "-- void --";
    os << "," << endl;
  }

  if (NOT_NULL (encryptedContent))
  {
    os << ","<< endl;
    Indent (os, indentG);
    os << "encryptedContent ";
    os << *encryptedContent;
  }
  else
  {
    Indent (os, indentG);
    os << "encryptedContent ";
    os << "-- void --";
    os << endl;
  }

  os << endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
#endif /* NDEBUG */
} // EncryptedContentInfo1::Print


EncryptedData1::EncryptedData1()
{
#if TCL
  encryptedContentInfo = new EncryptedContentInfo1;
#else
  encryptedContentInfo = NULL; // incomplete initialization of mandatory element!
#endif // TCL
}

EncryptedData1::EncryptedData1 (const EncryptedData1 &)
{
  Asn1Error << "use of incompletely defined EncryptedData1::EncryptedData1 (const EncryptedData1 &)" << endl;
  abort();
}

EncryptedData1::~EncryptedData1()
{
  delete encryptedContentInfo;
}

AsnType *EncryptedData1::Clone() const
{
  return new EncryptedData1;
}

AsnType *EncryptedData1::Copy() const
{
  return new EncryptedData1 (*this);
}

#if SNACC_DEEP_COPY
EncryptedData1 &EncryptedData1::operator = (const EncryptedData1 &that)
#else // SNACC_DEEP_COPY
EncryptedData1 &EncryptedData1::operator = (const EncryptedData1 &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    version = that.version;
    if (that.encryptedContentInfo)
    {
      if (!encryptedContentInfo)
        encryptedContentInfo = new EncryptedContentInfo1;
      *encryptedContentInfo = *that.encryptedContentInfo;
    }
    else
    {
      delete encryptedContentInfo;
      encryptedContentInfo = NULL;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined EncryptedData1 &EncryptedData1::operator = (const EncryptedData1 &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
EncryptedData1::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

      BEncEocIfNec (b);
    l = encryptedContentInfo->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;

    l = version.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

  return totalLen;
} // EncryptedData1::BEncContent


void EncryptedData1::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    version.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    SnaccExcep::throwMe(-104);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    encryptedContentInfo = new EncryptedContentInfo1;
    encryptedContentInfo->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    SnaccExcep::throwMe(-105);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << endl;
    SnaccExcep::throwMe(-106);
  }
  else
    return;
} // EncryptedData1::BDecContent

AsnLen EncryptedData1::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void EncryptedData1::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "EncryptedData1::BDec: ERROR - wrong tag" << endl;
    SnaccExcep::throwMe(-107);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

void EncryptedData1::Print (ostream &os) const
{
#ifndef NDEBUG
  os << "{ -- SEQUENCE --" << endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "version ";
    os << version;
    os << "," << endl;
  }

  if (NOT_NULL (encryptedContentInfo))
  {
    Indent (os, indentG);
    os << "encryptedContentInfo ";
    os << *encryptedContentInfo;
  }
  else
  {
    Indent (os, indentG);
    os << "encryptedContentInfo ";
    os << "-- void --";
    os << endl;
  }

  os << endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
#endif /* NDEBUG */
} // EncryptedData1::Print


