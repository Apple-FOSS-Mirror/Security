//   NOTE: this is a machine generated file--editing not recommended
//
// sm_ess.cpp - class member functions for ASN.1 module ExtendedSecurityServices
//
//   This file was generated by snacc on Mon Apr 22 22:34:19 2002
//   UBC snacc written by Mike Sample
//   A couple of enhancements made by IBM European Networking Center


#include "asn-incl.h"
#include "sm_vdatypes.h"
#include "sm_x501ud.h"
#include "sm_x411ub.h"
#include "sm_x411mtsas.h"
#include "sm_x501if.h"
#include "sm_x520sa.h"
#include "sm_x509cmn.h"
#include "sm_x509af.h"
#include "sm_x509ce.h"
#include "pkcs1oids.h"
#include "pkcs9oids.h"
#include "sm_cms.h"
#include "sm_ess.h"
#include "pkcs7.h"
#include "pkcs8.h"
#include "appleoids.h"
#include "pkcs10.h"

//------------------------------------------------------------------------------
// value defs


//------------------------------------------------------------------------------
// class member definitions:

AsnType *SigningCertificateSeqOf1::Clone() const
{
  return new SigningCertificateSeqOf1;
}

AsnType *SigningCertificateSeqOf1::Copy() const
{
  return new SigningCertificateSeqOf1 (*this);
}

AsnLen SigningCertificateSeqOf1::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void SigningCertificateSeqOf1::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "SigningCertificateSeqOf1::BDec: ERROR - wrong tag" << endl;
    SnaccExcep::throwMe(-100);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

SigningCertificateSeqOf1::SigningCertificateSeqOf1 (const SigningCertificateSeqOf1 &)
{
  Asn1Error << "use of incompletely defined SigningCertificateSeqOf1::SigningCertificateSeqOf1 (const SigningCertificateSeqOf1 &)" << endl;
  abort();
}

SigningCertificateSeqOf1::~SigningCertificateSeqOf1()
{
  SetCurrToFirst();
  for (; Curr() != NULL; RemoveCurrFromList())
    ;
} // end of destructor

#if SNACC_DEEP_COPY
SigningCertificateSeqOf1 &SigningCertificateSeqOf1::operator = (const SigningCertificateSeqOf1 &that)
#else // SNACC_DEEP_COPY
SigningCertificateSeqOf1 &SigningCertificateSeqOf1::operator = (const SigningCertificateSeqOf1 &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    SetCurrToFirst();
    for (; Curr(); RemoveCurrFromList())
      ;

    //that.SetCurrToFirst();
    //for (; that.Curr(); that.GoNext())
    //  AppendCopy (*that.Curr());
    for (const AsnListElmt *run=that.first; run; run=run->next)
      AppendCopy (*run->elmt);
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined SigningCertificateSeqOf1 &SigningCertificateSeqOf1::operator = (const SigningCertificateSeqOf1 &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

void SigningCertificateSeqOf1::Print (ostream &os) const
{
#ifndef NDEBUG
    os << "{ -- SEQUENCE/SET OF -- " << endl;
    indentG += stdIndentG;
    //SetCurrToFirst();
    //for (; Curr() != NULL; GoNext())
    for (const AsnListElmt *run=first; run; run=run->next)
    {
        Indent (os, indentG);
        //os << *Curr();
        os << *run->elmt;
        //if (Curr() != Last())
        if (run != last)
            os << ",";
        os << endl;
    }
    indentG -= stdIndentG;
    Indent (os, indentG);
    os << "}\n";
#endif /* NDEBUG */


} // Print


void  SigningCertificateSeqOf1::SetCurrElmt (unsigned long int index)
{
  unsigned long int i;
  curr = first;
  if (count)
    for (i = 0; (i < (count-1)) && (i < index); i++)
      curr = curr->next;
} // SigningCertificateSeqOf1::SetCurrElmt


unsigned long int  SigningCertificateSeqOf1::GetCurrElmtIndex()
{
    unsigned long int i;
    AsnListElmt *tmp;
    if (curr != NULL)
    {
        for (i = 0, tmp = first; tmp != NULL; i++)
        {
            if (tmp == curr)
                return i;
            else
                tmp = tmp->next;
        }
    }
    return count;
} // SigningCertificateSeqOf1::GetCurrElmtIndex


// alloc new list elmt, put at end of list
//  and return the component type
PolicyInformation *SigningCertificateSeqOf1::Append()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new PolicyInformation;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // SigningCertificateSeqOf1::Append


// alloc new list elmt, put at begining of list
//  and return the component type
PolicyInformation  *SigningCertificateSeqOf1::Prepend()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new PolicyInformation;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // SigningCertificateSeqOf1::Prepend


// alloc new list elmt, insert it before the
// current element and return the component type
// if the current element is null, the new element
// is placed at the beginning of the list.
PolicyInformation  *SigningCertificateSeqOf1::InsertBefore()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new PolicyInformation;
    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // SigningCertificateSeqOf1::InsertBefore


// alloc new list elmt, insert it after the
// current element and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
PolicyInformation *SigningCertificateSeqOf1::InsertAfter()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new PolicyInformation;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // SigningCertificateSeqOf1::InsertAfter


SigningCertificateSeqOf1  &SigningCertificateSeqOf1::AppendCopy (PolicyInformation &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new PolicyInformation;
    *newElmt->elmt = elmt;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return *this;
} // AppendCopy


SigningCertificateSeqOf1  &SigningCertificateSeqOf1::PrependCopy (PolicyInformation &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new PolicyInformation;
    *newElmt->elmt = elmt;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return *this;
} // SigningCertificateSeqOf1::PrependCopy


// alloc new list elmt, insert it before the
// current element, copy the given elmt into the new elmt
// and return the component type.
// if the current element is null, the new element
// is placed at the beginning of the list.
SigningCertificateSeqOf1 &SigningCertificateSeqOf1::InsertBeforeAndCopy (PolicyInformation &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new PolicyInformation;
    *newElmt->elmt = elmt;

    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return *this;
} // SigningCertificateSeqOf1::InsertBeforeAndCopy


// alloc new list elmt, insert it after the
// current element, copy given elmt in to new elmt
//  and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
SigningCertificateSeqOf1  &SigningCertificateSeqOf1::InsertAfterAndCopy (PolicyInformation &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new PolicyInformation;
    *newElmt->elmt = elmt;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return *this;
} // SigningCertificateSeqOf1::InsertAfterAndCopy


// remove current element from list if current element is not NULL 
// The new current element will be the next element.
// If the current element is the last element in the list
// the second but last element will become the new current element.
void SigningCertificateSeqOf1::RemoveCurrFromList()
{
    AsnListElmt *del_elmt;

    if (curr != NULL)
    {
        del_elmt = curr;
        count--;

        if (count == 0)
            first = last = curr = NULL;
        else if (curr == first)
        {
            curr = first= first->next;
            first->prev = NULL;
        }
        else if (curr == last)
        {
            curr = last = last->prev;
            last->next = NULL;
        }
        else
        {
            curr->prev->next = curr->next;
            curr->next->prev = curr->prev;
        }

        delete del_elmt->elmt;
        delete del_elmt;
    }
}


AsnLen SigningCertificateSeqOf1::BEncContent (BUF_TYPE b)
{
    AsnListElmt *currElmt;
    AsnLen elmtLen;
    AsnLen totalLen = 0;
    for (currElmt = last; currElmt != NULL; currElmt = currElmt->prev)
    {
      BEncEocIfNec (b);
        elmtLen = currElmt->elmt->BEncContent (b);
    elmtLen += BEncConsLen (b, elmtLen);

    elmtLen += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
        totalLen += elmtLen;
    }
    return totalLen;
} // SigningCertificateSeqOf1::BEncContent


void  SigningCertificateSeqOf1::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0,
                                  AsnLen &bytesDecoded, ENV_TYPE env)
{
    PolicyInformation *listElmt;
    AsnTag tag1;
    AsnLen listBytesDecoded = 0;
    AsnLen elmtLen1;

    while ((listBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN))
    {
        tag1 = BDecTag (b, listBytesDecoded, env);
        if ((tag1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
        {
            BDEC_2ND_EOC_OCTET (b, listBytesDecoded, env);
            break;
        }
        if ((tag1 != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
        {
            Asn1Error << "Unexpected Tag" << endl;
            SnaccExcep::throwMe(-101);
        }

        elmtLen1 = BDecLen (b, listBytesDecoded, env);
        listElmt = Append();
        listElmt->BDecContent (b, tag1, elmtLen1, listBytesDecoded, env);
    }

    bytesDecoded += listBytesDecoded;
} // SigningCertificateSeqOf1::BDecContent


AsnType *MLReceiptPolicySeqOf1::Clone() const
{
  return new MLReceiptPolicySeqOf1;
}

AsnType *MLReceiptPolicySeqOf1::Copy() const
{
  return new MLReceiptPolicySeqOf1 (*this);
}

AsnLen MLReceiptPolicySeqOf1::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void MLReceiptPolicySeqOf1::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "MLReceiptPolicySeqOf1::BDec: ERROR - wrong tag" << endl;
    SnaccExcep::throwMe(-102);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

MLReceiptPolicySeqOf1::MLReceiptPolicySeqOf1 (const MLReceiptPolicySeqOf1 &)
{
  Asn1Error << "use of incompletely defined MLReceiptPolicySeqOf1::MLReceiptPolicySeqOf1 (const MLReceiptPolicySeqOf1 &)" << endl;
  abort();
}

MLReceiptPolicySeqOf1::~MLReceiptPolicySeqOf1()
{
  SetCurrToFirst();
  for (; Curr() != NULL; RemoveCurrFromList())
    ;
} // end of destructor

#if SNACC_DEEP_COPY
MLReceiptPolicySeqOf1 &MLReceiptPolicySeqOf1::operator = (const MLReceiptPolicySeqOf1 &that)
#else // SNACC_DEEP_COPY
MLReceiptPolicySeqOf1 &MLReceiptPolicySeqOf1::operator = (const MLReceiptPolicySeqOf1 &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    SetCurrToFirst();
    for (; Curr(); RemoveCurrFromList())
      ;

    //that.SetCurrToFirst();
    //for (; that.Curr(); that.GoNext())
    //  AppendCopy (*that.Curr());
    for (const AsnListElmt *run=that.first; run; run=run->next)
      AppendCopy (*run->elmt);
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined MLReceiptPolicySeqOf1 &MLReceiptPolicySeqOf1::operator = (const MLReceiptPolicySeqOf1 &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

void MLReceiptPolicySeqOf1::Print (ostream &os) const
{
#ifndef NDEBUG
    os << "{ -- SEQUENCE/SET OF -- " << endl;
    indentG += stdIndentG;
    //SetCurrToFirst();
    //for (; Curr() != NULL; GoNext())
    for (const AsnListElmt *run=first; run; run=run->next)
    {
        Indent (os, indentG);
        //os << *Curr();
        os << *run->elmt;
        //if (Curr() != Last())
        if (run != last)
            os << ",";
        os << endl;
    }
    indentG -= stdIndentG;
    Indent (os, indentG);
    os << "}\n";
#endif /* NDEBUG */


} // Print


void  MLReceiptPolicySeqOf1::SetCurrElmt (unsigned long int index)
{
  unsigned long int i;
  curr = first;
  if (count)
    for (i = 0; (i < (count-1)) && (i < index); i++)
      curr = curr->next;
} // MLReceiptPolicySeqOf1::SetCurrElmt


unsigned long int  MLReceiptPolicySeqOf1::GetCurrElmtIndex()
{
    unsigned long int i;
    AsnListElmt *tmp;
    if (curr != NULL)
    {
        for (i = 0, tmp = first; tmp != NULL; i++)
        {
            if (tmp == curr)
                return i;
            else
                tmp = tmp->next;
        }
    }
    return count;
} // MLReceiptPolicySeqOf1::GetCurrElmtIndex


// alloc new list elmt, put at end of list
//  and return the component type
GeneralNames *MLReceiptPolicySeqOf1::Append()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new GeneralNames;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // MLReceiptPolicySeqOf1::Append


// alloc new list elmt, put at begining of list
//  and return the component type
GeneralNames  *MLReceiptPolicySeqOf1::Prepend()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new GeneralNames;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // MLReceiptPolicySeqOf1::Prepend


// alloc new list elmt, insert it before the
// current element and return the component type
// if the current element is null, the new element
// is placed at the beginning of the list.
GeneralNames  *MLReceiptPolicySeqOf1::InsertBefore()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new GeneralNames;
    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // MLReceiptPolicySeqOf1::InsertBefore


// alloc new list elmt, insert it after the
// current element and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
GeneralNames *MLReceiptPolicySeqOf1::InsertAfter()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new GeneralNames;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // MLReceiptPolicySeqOf1::InsertAfter


MLReceiptPolicySeqOf1  &MLReceiptPolicySeqOf1::AppendCopy (GeneralNames &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new GeneralNames;
    *newElmt->elmt = elmt;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return *this;
} // AppendCopy


MLReceiptPolicySeqOf1  &MLReceiptPolicySeqOf1::PrependCopy (GeneralNames &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new GeneralNames;
    *newElmt->elmt = elmt;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return *this;
} // MLReceiptPolicySeqOf1::PrependCopy


// alloc new list elmt, insert it before the
// current element, copy the given elmt into the new elmt
// and return the component type.
// if the current element is null, the new element
// is placed at the beginning of the list.
MLReceiptPolicySeqOf1 &MLReceiptPolicySeqOf1::InsertBeforeAndCopy (GeneralNames &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new GeneralNames;
    *newElmt->elmt = elmt;

    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return *this;
} // MLReceiptPolicySeqOf1::InsertBeforeAndCopy


// alloc new list elmt, insert it after the
// current element, copy given elmt in to new elmt
//  and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
MLReceiptPolicySeqOf1  &MLReceiptPolicySeqOf1::InsertAfterAndCopy (GeneralNames &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new GeneralNames;
    *newElmt->elmt = elmt;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return *this;
} // MLReceiptPolicySeqOf1::InsertAfterAndCopy


// remove current element from list if current element is not NULL 
// The new current element will be the next element.
// If the current element is the last element in the list
// the second but last element will become the new current element.
void MLReceiptPolicySeqOf1::RemoveCurrFromList()
{
    AsnListElmt *del_elmt;

    if (curr != NULL)
    {
        del_elmt = curr;
        count--;

        if (count == 0)
            first = last = curr = NULL;
        else if (curr == first)
        {
            curr = first= first->next;
            first->prev = NULL;
        }
        else if (curr == last)
        {
            curr = last = last->prev;
            last->next = NULL;
        }
        else
        {
            curr->prev->next = curr->next;
            curr->next->prev = curr->prev;
        }

        delete del_elmt->elmt;
        delete del_elmt;
    }
}


AsnLen MLReceiptPolicySeqOf1::BEncContent (BUF_TYPE b)
{
    AsnListElmt *currElmt;
    AsnLen elmtLen;
    AsnLen totalLen = 0;
    for (currElmt = last; currElmt != NULL; currElmt = currElmt->prev)
    {
      BEncEocIfNec (b);
        elmtLen = currElmt->elmt->BEncContent (b);
    elmtLen += BEncConsLen (b, elmtLen);

    elmtLen += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
        totalLen += elmtLen;
    }
    return totalLen;
} // MLReceiptPolicySeqOf1::BEncContent


void  MLReceiptPolicySeqOf1::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0,
                                  AsnLen &bytesDecoded, ENV_TYPE env)
{
    GeneralNames *listElmt;
    AsnTag tag1;
    AsnLen listBytesDecoded = 0;
    AsnLen elmtLen1;

    while ((listBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN))
    {
        tag1 = BDecTag (b, listBytesDecoded, env);
        if ((tag1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
        {
            BDEC_2ND_EOC_OCTET (b, listBytesDecoded, env);
            break;
        }
        if ((tag1 != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
        {
            Asn1Error << "Unexpected Tag" << endl;
            SnaccExcep::throwMe(-103);
        }

        elmtLen1 = BDecLen (b, listBytesDecoded, env);
        listElmt = Append();
        listElmt->BDecContent (b, tag1, elmtLen1, listBytesDecoded, env);
    }

    bytesDecoded += listBytesDecoded;
} // MLReceiptPolicySeqOf1::BDecContent


AsnType *MLReceiptPolicySeqOf::Clone() const
{
  return new MLReceiptPolicySeqOf;
}

AsnType *MLReceiptPolicySeqOf::Copy() const
{
  return new MLReceiptPolicySeqOf (*this);
}

AsnLen MLReceiptPolicySeqOf::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void MLReceiptPolicySeqOf::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "MLReceiptPolicySeqOf::BDec: ERROR - wrong tag" << endl;
    SnaccExcep::throwMe(-104);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

MLReceiptPolicySeqOf::MLReceiptPolicySeqOf (const MLReceiptPolicySeqOf &)
{
  Asn1Error << "use of incompletely defined MLReceiptPolicySeqOf::MLReceiptPolicySeqOf (const MLReceiptPolicySeqOf &)" << endl;
  abort();
}

MLReceiptPolicySeqOf::~MLReceiptPolicySeqOf()
{
  SetCurrToFirst();
  for (; Curr() != NULL; RemoveCurrFromList())
    ;
} // end of destructor

#if SNACC_DEEP_COPY
MLReceiptPolicySeqOf &MLReceiptPolicySeqOf::operator = (const MLReceiptPolicySeqOf &that)
#else // SNACC_DEEP_COPY
MLReceiptPolicySeqOf &MLReceiptPolicySeqOf::operator = (const MLReceiptPolicySeqOf &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    SetCurrToFirst();
    for (; Curr(); RemoveCurrFromList())
      ;

    //that.SetCurrToFirst();
    //for (; that.Curr(); that.GoNext())
    //  AppendCopy (*that.Curr());
    for (const AsnListElmt *run=that.first; run; run=run->next)
      AppendCopy (*run->elmt);
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined MLReceiptPolicySeqOf &MLReceiptPolicySeqOf::operator = (const MLReceiptPolicySeqOf &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

void MLReceiptPolicySeqOf::Print (ostream &os) const
{
#ifndef NDEBUG
    os << "{ -- SEQUENCE/SET OF -- " << endl;
    indentG += stdIndentG;
    //SetCurrToFirst();
    //for (; Curr() != NULL; GoNext())
    for (const AsnListElmt *run=first; run; run=run->next)
    {
        Indent (os, indentG);
        //os << *Curr();
        os << *run->elmt;
        //if (Curr() != Last())
        if (run != last)
            os << ",";
        os << endl;
    }
    indentG -= stdIndentG;
    Indent (os, indentG);
    os << "}\n";
#endif /* NDEBUG */


} // Print


void  MLReceiptPolicySeqOf::SetCurrElmt (unsigned long int index)
{
  unsigned long int i;
  curr = first;
  if (count)
    for (i = 0; (i < (count-1)) && (i < index); i++)
      curr = curr->next;
} // MLReceiptPolicySeqOf::SetCurrElmt


unsigned long int  MLReceiptPolicySeqOf::GetCurrElmtIndex()
{
    unsigned long int i;
    AsnListElmt *tmp;
    if (curr != NULL)
    {
        for (i = 0, tmp = first; tmp != NULL; i++)
        {
            if (tmp == curr)
                return i;
            else
                tmp = tmp->next;
        }
    }
    return count;
} // MLReceiptPolicySeqOf::GetCurrElmtIndex


// alloc new list elmt, put at end of list
//  and return the component type
GeneralNames *MLReceiptPolicySeqOf::Append()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new GeneralNames;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // MLReceiptPolicySeqOf::Append


// alloc new list elmt, put at begining of list
//  and return the component type
GeneralNames  *MLReceiptPolicySeqOf::Prepend()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new GeneralNames;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // MLReceiptPolicySeqOf::Prepend


// alloc new list elmt, insert it before the
// current element and return the component type
// if the current element is null, the new element
// is placed at the beginning of the list.
GeneralNames  *MLReceiptPolicySeqOf::InsertBefore()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new GeneralNames;
    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // MLReceiptPolicySeqOf::InsertBefore


// alloc new list elmt, insert it after the
// current element and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
GeneralNames *MLReceiptPolicySeqOf::InsertAfter()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new GeneralNames;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // MLReceiptPolicySeqOf::InsertAfter


MLReceiptPolicySeqOf  &MLReceiptPolicySeqOf::AppendCopy (GeneralNames &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new GeneralNames;
    *newElmt->elmt = elmt;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return *this;
} // AppendCopy


MLReceiptPolicySeqOf  &MLReceiptPolicySeqOf::PrependCopy (GeneralNames &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new GeneralNames;
    *newElmt->elmt = elmt;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return *this;
} // MLReceiptPolicySeqOf::PrependCopy


// alloc new list elmt, insert it before the
// current element, copy the given elmt into the new elmt
// and return the component type.
// if the current element is null, the new element
// is placed at the beginning of the list.
MLReceiptPolicySeqOf &MLReceiptPolicySeqOf::InsertBeforeAndCopy (GeneralNames &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new GeneralNames;
    *newElmt->elmt = elmt;

    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return *this;
} // MLReceiptPolicySeqOf::InsertBeforeAndCopy


// alloc new list elmt, insert it after the
// current element, copy given elmt in to new elmt
//  and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
MLReceiptPolicySeqOf  &MLReceiptPolicySeqOf::InsertAfterAndCopy (GeneralNames &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new GeneralNames;
    *newElmt->elmt = elmt;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return *this;
} // MLReceiptPolicySeqOf::InsertAfterAndCopy


// remove current element from list if current element is not NULL 
// The new current element will be the next element.
// If the current element is the last element in the list
// the second but last element will become the new current element.
void MLReceiptPolicySeqOf::RemoveCurrFromList()
{
    AsnListElmt *del_elmt;

    if (curr != NULL)
    {
        del_elmt = curr;
        count--;

        if (count == 0)
            first = last = curr = NULL;
        else if (curr == first)
        {
            curr = first= first->next;
            first->prev = NULL;
        }
        else if (curr == last)
        {
            curr = last = last->prev;
            last->next = NULL;
        }
        else
        {
            curr->prev->next = curr->next;
            curr->next->prev = curr->prev;
        }

        delete del_elmt->elmt;
        delete del_elmt;
    }
}


AsnLen MLReceiptPolicySeqOf::BEncContent (BUF_TYPE b)
{
    AsnListElmt *currElmt;
    AsnLen elmtLen;
    AsnLen totalLen = 0;
    for (currElmt = last; currElmt != NULL; currElmt = currElmt->prev)
    {
      BEncEocIfNec (b);
        elmtLen = currElmt->elmt->BEncContent (b);
    elmtLen += BEncConsLen (b, elmtLen);

    elmtLen += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
        totalLen += elmtLen;
    }
    return totalLen;
} // MLReceiptPolicySeqOf::BEncContent


void  MLReceiptPolicySeqOf::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0,
                                  AsnLen &bytesDecoded, ENV_TYPE env)
{
    GeneralNames *listElmt;
    AsnTag tag1;
    AsnLen listBytesDecoded = 0;
    AsnLen elmtLen1;

    while ((listBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN))
    {
        tag1 = BDecTag (b, listBytesDecoded, env);
        if ((tag1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
        {
            BDEC_2ND_EOC_OCTET (b, listBytesDecoded, env);
            break;
        }
        if ((tag1 != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
        {
            Asn1Error << "Unexpected Tag" << endl;
            SnaccExcep::throwMe(-105);
        }

        elmtLen1 = BDecLen (b, listBytesDecoded, env);
        listElmt = Append();
        listElmt->BDecContent (b, tag1, elmtLen1, listBytesDecoded, env);
    }

    bytesDecoded += listBytesDecoded;
} // MLReceiptPolicySeqOf::BDecContent


AsnType *ReceiptsFromSeqOf::Clone() const
{
  return new ReceiptsFromSeqOf;
}

AsnType *ReceiptsFromSeqOf::Copy() const
{
  return new ReceiptsFromSeqOf (*this);
}

AsnLen ReceiptsFromSeqOf::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void ReceiptsFromSeqOf::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "ReceiptsFromSeqOf::BDec: ERROR - wrong tag" << endl;
    SnaccExcep::throwMe(-106);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

ReceiptsFromSeqOf::ReceiptsFromSeqOf (const ReceiptsFromSeqOf &)
{
  Asn1Error << "use of incompletely defined ReceiptsFromSeqOf::ReceiptsFromSeqOf (const ReceiptsFromSeqOf &)" << endl;
  abort();
}

ReceiptsFromSeqOf::~ReceiptsFromSeqOf()
{
  SetCurrToFirst();
  for (; Curr() != NULL; RemoveCurrFromList())
    ;
} // end of destructor

#if SNACC_DEEP_COPY
ReceiptsFromSeqOf &ReceiptsFromSeqOf::operator = (const ReceiptsFromSeqOf &that)
#else // SNACC_DEEP_COPY
ReceiptsFromSeqOf &ReceiptsFromSeqOf::operator = (const ReceiptsFromSeqOf &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    SetCurrToFirst();
    for (; Curr(); RemoveCurrFromList())
      ;

    //that.SetCurrToFirst();
    //for (; that.Curr(); that.GoNext())
    //  AppendCopy (*that.Curr());
    for (const AsnListElmt *run=that.first; run; run=run->next)
      AppendCopy (*run->elmt);
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined ReceiptsFromSeqOf &ReceiptsFromSeqOf::operator = (const ReceiptsFromSeqOf &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

void ReceiptsFromSeqOf::Print (ostream &os) const
{
#ifndef NDEBUG
    os << "{ -- SEQUENCE/SET OF -- " << endl;
    indentG += stdIndentG;
    //SetCurrToFirst();
    //for (; Curr() != NULL; GoNext())
    for (const AsnListElmt *run=first; run; run=run->next)
    {
        Indent (os, indentG);
        //os << *Curr();
        os << *run->elmt;
        //if (Curr() != Last())
        if (run != last)
            os << ",";
        os << endl;
    }
    indentG -= stdIndentG;
    Indent (os, indentG);
    os << "}\n";
#endif /* NDEBUG */


} // Print


void  ReceiptsFromSeqOf::SetCurrElmt (unsigned long int index)
{
  unsigned long int i;
  curr = first;
  if (count)
    for (i = 0; (i < (count-1)) && (i < index); i++)
      curr = curr->next;
} // ReceiptsFromSeqOf::SetCurrElmt


unsigned long int  ReceiptsFromSeqOf::GetCurrElmtIndex()
{
    unsigned long int i;
    AsnListElmt *tmp;
    if (curr != NULL)
    {
        for (i = 0, tmp = first; tmp != NULL; i++)
        {
            if (tmp == curr)
                return i;
            else
                tmp = tmp->next;
        }
    }
    return count;
} // ReceiptsFromSeqOf::GetCurrElmtIndex


// alloc new list elmt, put at end of list
//  and return the component type
GeneralNames *ReceiptsFromSeqOf::Append()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new GeneralNames;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // ReceiptsFromSeqOf::Append


// alloc new list elmt, put at begining of list
//  and return the component type
GeneralNames  *ReceiptsFromSeqOf::Prepend()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new GeneralNames;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // ReceiptsFromSeqOf::Prepend


// alloc new list elmt, insert it before the
// current element and return the component type
// if the current element is null, the new element
// is placed at the beginning of the list.
GeneralNames  *ReceiptsFromSeqOf::InsertBefore()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new GeneralNames;
    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // ReceiptsFromSeqOf::InsertBefore


// alloc new list elmt, insert it after the
// current element and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
GeneralNames *ReceiptsFromSeqOf::InsertAfter()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new GeneralNames;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // ReceiptsFromSeqOf::InsertAfter


ReceiptsFromSeqOf  &ReceiptsFromSeqOf::AppendCopy (GeneralNames &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new GeneralNames;
    *newElmt->elmt = elmt;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return *this;
} // AppendCopy


ReceiptsFromSeqOf  &ReceiptsFromSeqOf::PrependCopy (GeneralNames &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new GeneralNames;
    *newElmt->elmt = elmt;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return *this;
} // ReceiptsFromSeqOf::PrependCopy


// alloc new list elmt, insert it before the
// current element, copy the given elmt into the new elmt
// and return the component type.
// if the current element is null, the new element
// is placed at the beginning of the list.
ReceiptsFromSeqOf &ReceiptsFromSeqOf::InsertBeforeAndCopy (GeneralNames &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new GeneralNames;
    *newElmt->elmt = elmt;

    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return *this;
} // ReceiptsFromSeqOf::InsertBeforeAndCopy


// alloc new list elmt, insert it after the
// current element, copy given elmt in to new elmt
//  and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
ReceiptsFromSeqOf  &ReceiptsFromSeqOf::InsertAfterAndCopy (GeneralNames &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new GeneralNames;
    *newElmt->elmt = elmt;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return *this;
} // ReceiptsFromSeqOf::InsertAfterAndCopy


// remove current element from list if current element is not NULL 
// The new current element will be the next element.
// If the current element is the last element in the list
// the second but last element will become the new current element.
void ReceiptsFromSeqOf::RemoveCurrFromList()
{
    AsnListElmt *del_elmt;

    if (curr != NULL)
    {
        del_elmt = curr;
        count--;

        if (count == 0)
            first = last = curr = NULL;
        else if (curr == first)
        {
            curr = first= first->next;
            first->prev = NULL;
        }
        else if (curr == last)
        {
            curr = last = last->prev;
            last->next = NULL;
        }
        else
        {
            curr->prev->next = curr->next;
            curr->next->prev = curr->prev;
        }

        delete del_elmt->elmt;
        delete del_elmt;
    }
}


AsnLen ReceiptsFromSeqOf::BEncContent (BUF_TYPE b)
{
    AsnListElmt *currElmt;
    AsnLen elmtLen;
    AsnLen totalLen = 0;
    for (currElmt = last; currElmt != NULL; currElmt = currElmt->prev)
    {
      BEncEocIfNec (b);
        elmtLen = currElmt->elmt->BEncContent (b);
    elmtLen += BEncConsLen (b, elmtLen);

    elmtLen += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
        totalLen += elmtLen;
    }
    return totalLen;
} // ReceiptsFromSeqOf::BEncContent


void  ReceiptsFromSeqOf::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0,
                                  AsnLen &bytesDecoded, ENV_TYPE env)
{
    GeneralNames *listElmt;
    AsnTag tag1;
    AsnLen listBytesDecoded = 0;
    AsnLen elmtLen1;

    while ((listBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN))
    {
        tag1 = BDecTag (b, listBytesDecoded, env);
        if ((tag1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
        {
            BDEC_2ND_EOC_OCTET (b, listBytesDecoded, env);
            break;
        }
        if ((tag1 != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
        {
            Asn1Error << "Unexpected Tag" << endl;
            SnaccExcep::throwMe(-107);
        }

        elmtLen1 = BDecLen (b, listBytesDecoded, env);
        listElmt = Append();
        listElmt->BDecContent (b, tag1, elmtLen1, listBytesDecoded, env);
    }

    bytesDecoded += listBytesDecoded;
} // ReceiptsFromSeqOf::BDecContent


AsnType *ReceiptRequestSeqOf::Clone() const
{
  return new ReceiptRequestSeqOf;
}

AsnType *ReceiptRequestSeqOf::Copy() const
{
  return new ReceiptRequestSeqOf (*this);
}

AsnLen ReceiptRequestSeqOf::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void ReceiptRequestSeqOf::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "ReceiptRequestSeqOf::BDec: ERROR - wrong tag" << endl;
    SnaccExcep::throwMe(-108);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

ReceiptRequestSeqOf::ReceiptRequestSeqOf (const ReceiptRequestSeqOf &)
{
  Asn1Error << "use of incompletely defined ReceiptRequestSeqOf::ReceiptRequestSeqOf (const ReceiptRequestSeqOf &)" << endl;
  abort();
}

ReceiptRequestSeqOf::~ReceiptRequestSeqOf()
{
  SetCurrToFirst();
  for (; Curr() != NULL; RemoveCurrFromList())
    ;
} // end of destructor

#if SNACC_DEEP_COPY
ReceiptRequestSeqOf &ReceiptRequestSeqOf::operator = (const ReceiptRequestSeqOf &that)
#else // SNACC_DEEP_COPY
ReceiptRequestSeqOf &ReceiptRequestSeqOf::operator = (const ReceiptRequestSeqOf &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    SetCurrToFirst();
    for (; Curr(); RemoveCurrFromList())
      ;

    //that.SetCurrToFirst();
    //for (; that.Curr(); that.GoNext())
    //  AppendCopy (*that.Curr());
    for (const AsnListElmt *run=that.first; run; run=run->next)
      AppendCopy (*run->elmt);
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined ReceiptRequestSeqOf &ReceiptRequestSeqOf::operator = (const ReceiptRequestSeqOf &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

void ReceiptRequestSeqOf::Print (ostream &os) const
{
#ifndef NDEBUG
    os << "{ -- SEQUENCE/SET OF -- " << endl;
    indentG += stdIndentG;
    //SetCurrToFirst();
    //for (; Curr() != NULL; GoNext())
    for (const AsnListElmt *run=first; run; run=run->next)
    {
        Indent (os, indentG);
        //os << *Curr();
        os << *run->elmt;
        //if (Curr() != Last())
        if (run != last)
            os << ",";
        os << endl;
    }
    indentG -= stdIndentG;
    Indent (os, indentG);
    os << "}\n";
#endif /* NDEBUG */


} // Print


void  ReceiptRequestSeqOf::SetCurrElmt (unsigned long int index)
{
  unsigned long int i;
  curr = first;
  if (count)
    for (i = 0; (i < (count-1)) && (i < index); i++)
      curr = curr->next;
} // ReceiptRequestSeqOf::SetCurrElmt


unsigned long int  ReceiptRequestSeqOf::GetCurrElmtIndex()
{
    unsigned long int i;
    AsnListElmt *tmp;
    if (curr != NULL)
    {
        for (i = 0, tmp = first; tmp != NULL; i++)
        {
            if (tmp == curr)
                return i;
            else
                tmp = tmp->next;
        }
    }
    return count;
} // ReceiptRequestSeqOf::GetCurrElmtIndex


// alloc new list elmt, put at end of list
//  and return the component type
GeneralNames *ReceiptRequestSeqOf::Append()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new GeneralNames;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // ReceiptRequestSeqOf::Append


// alloc new list elmt, put at begining of list
//  and return the component type
GeneralNames  *ReceiptRequestSeqOf::Prepend()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new GeneralNames;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // ReceiptRequestSeqOf::Prepend


// alloc new list elmt, insert it before the
// current element and return the component type
// if the current element is null, the new element
// is placed at the beginning of the list.
GeneralNames  *ReceiptRequestSeqOf::InsertBefore()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new GeneralNames;
    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // ReceiptRequestSeqOf::InsertBefore


// alloc new list elmt, insert it after the
// current element and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
GeneralNames *ReceiptRequestSeqOf::InsertAfter()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new GeneralNames;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // ReceiptRequestSeqOf::InsertAfter


ReceiptRequestSeqOf  &ReceiptRequestSeqOf::AppendCopy (GeneralNames &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new GeneralNames;
    *newElmt->elmt = elmt;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return *this;
} // AppendCopy


ReceiptRequestSeqOf  &ReceiptRequestSeqOf::PrependCopy (GeneralNames &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new GeneralNames;
    *newElmt->elmt = elmt;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return *this;
} // ReceiptRequestSeqOf::PrependCopy


// alloc new list elmt, insert it before the
// current element, copy the given elmt into the new elmt
// and return the component type.
// if the current element is null, the new element
// is placed at the beginning of the list.
ReceiptRequestSeqOf &ReceiptRequestSeqOf::InsertBeforeAndCopy (GeneralNames &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new GeneralNames;
    *newElmt->elmt = elmt;

    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return *this;
} // ReceiptRequestSeqOf::InsertBeforeAndCopy


// alloc new list elmt, insert it after the
// current element, copy given elmt in to new elmt
//  and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
ReceiptRequestSeqOf  &ReceiptRequestSeqOf::InsertAfterAndCopy (GeneralNames &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new GeneralNames;
    *newElmt->elmt = elmt;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return *this;
} // ReceiptRequestSeqOf::InsertAfterAndCopy


// remove current element from list if current element is not NULL 
// The new current element will be the next element.
// If the current element is the last element in the list
// the second but last element will become the new current element.
void ReceiptRequestSeqOf::RemoveCurrFromList()
{
    AsnListElmt *del_elmt;

    if (curr != NULL)
    {
        del_elmt = curr;
        count--;

        if (count == 0)
            first = last = curr = NULL;
        else if (curr == first)
        {
            curr = first= first->next;
            first->prev = NULL;
        }
        else if (curr == last)
        {
            curr = last = last->prev;
            last->next = NULL;
        }
        else
        {
            curr->prev->next = curr->next;
            curr->next->prev = curr->prev;
        }

        delete del_elmt->elmt;
        delete del_elmt;
    }
}


AsnLen ReceiptRequestSeqOf::BEncContent (BUF_TYPE b)
{
    AsnListElmt *currElmt;
    AsnLen elmtLen;
    AsnLen totalLen = 0;
    for (currElmt = last; currElmt != NULL; currElmt = currElmt->prev)
    {
      BEncEocIfNec (b);
        elmtLen = currElmt->elmt->BEncContent (b);
    elmtLen += BEncConsLen (b, elmtLen);

    elmtLen += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
        totalLen += elmtLen;
    }
    return totalLen;
} // ReceiptRequestSeqOf::BEncContent


void  ReceiptRequestSeqOf::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0,
                                  AsnLen &bytesDecoded, ENV_TYPE env)
{
    GeneralNames *listElmt;
    AsnTag tag1;
    AsnLen listBytesDecoded = 0;
    AsnLen elmtLen1;

    while ((listBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN))
    {
        tag1 = BDecTag (b, listBytesDecoded, env);
        if ((tag1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
        {
            BDEC_2ND_EOC_OCTET (b, listBytesDecoded, env);
            break;
        }
        if ((tag1 != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
        {
            Asn1Error << "Unexpected Tag" << endl;
            SnaccExcep::throwMe(-109);
        }

        elmtLen1 = BDecLen (b, listBytesDecoded, env);
        listElmt = Append();
        listElmt->BDecContent (b, tag1, elmtLen1, listBytesDecoded, env);
    }

    bytesDecoded += listBytesDecoded;
} // ReceiptRequestSeqOf::BDecContent


ESSPrivacyMark::ESSPrivacyMark()
{
  choiceId = pStringCid;
#if TCL
  pString = new PrintableString;
#else
  pString = NULL; // incomplete initialization of mandatory element!
#endif // TCL
}

ESSPrivacyMark::ESSPrivacyMark (const ESSPrivacyMark &)
{
  Asn1Error << "use of incompletely defined ESSPrivacyMark::ESSPrivacyMark (const ESSPrivacyMark &)" << endl;
  abort();
}

ESSPrivacyMark::~ESSPrivacyMark()
{
  switch (choiceId)
  {
    case pStringCid:
      delete pString;
      break;
    case utf8StringCid:
      delete utf8String;
      break;
  } // end of switch
} // end of destructor

AsnType *ESSPrivacyMark::Clone() const
{
  return new ESSPrivacyMark;
}

AsnType *ESSPrivacyMark::Copy() const
{
  return new ESSPrivacyMark (*this);
}

#if SNACC_DEEP_COPY
ESSPrivacyMark &ESSPrivacyMark::operator = (const ESSPrivacyMark &that)
#else // SNACC_DEEP_COPY
ESSPrivacyMark &ESSPrivacyMark::operator = (const ESSPrivacyMark &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    switch (choiceId)
    {
      case pStringCid:
        delete pString;
        break;
      case utf8StringCid:
        delete utf8String;
        break;
    }
    switch (choiceId = that.choiceId)
    {
      case pStringCid:
        pString = new PrintableString;
        *pString = *that.pString;
        break;
      case utf8StringCid:
        utf8String = new UTF8String;
        *utf8String = *that.utf8String;
        break;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined ESSPrivacyMark &ESSPrivacyMark::operator = (const ESSPrivacyMark &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
ESSPrivacyMark::BEncContent (BUF_TYPE b)
{
  AsnLen l;
  switch (choiceId)
  {
    case pStringCid:
      l = pString->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, UNIV, PRIM, PRINTABLESTRING_TAG_CODE);
      break;

    case utf8StringCid:
      l = utf8String->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, UNIV, PRIM, 12);
      break;

  } // end switch
  return l;
} // ESSPrivacyMark::BEncContent


void ESSPrivacyMark::BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  switch (tag)
  {
    case MAKE_TAG_ID (UNIV, PRIM, PRINTABLESTRING_TAG_CODE):
    case MAKE_TAG_ID (UNIV, CONS, PRINTABLESTRING_TAG_CODE):
      choiceId = pStringCid;
      pString = new PrintableString;
        pString->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (UNIV, PRIM, 12):
    case MAKE_TAG_ID (UNIV, CONS, 12):
      choiceId = utf8StringCid;
      utf8String = new UTF8String;
        utf8String->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    default:
      Asn1Error << "ERROR - unexpected tag in CHOICE" << endl;
      SnaccExcep::throwMe(-110);
      break;
  } // end switch
} // ESSPrivacyMark::BDecContent


AsnLen ESSPrivacyMark::BEnc (BUF_TYPE b)
{
    AsnLen l;
    l = BEncContent (b);
    return l;
}

void ESSPrivacyMark::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnLen elmtLen;
    AsnTag tag;

    /*  CHOICEs are a special case - grab identifying tag */
    /*  this allows easier handling of nested CHOICEs */
    tag = BDecTag (b, bytesDecoded, env);
    elmtLen = BDecLen (b, bytesDecoded, env);
    BDecContent (b, tag, elmtLen, bytesDecoded, env);
}

void ESSPrivacyMark::Print (ostream &os) const
{
#ifndef NDEBUG
  switch (choiceId)
  {
    case pStringCid:
      os << "pString ";
      if (pString)
        os << *pString;
      else
        os << "-- void3 --\n";
      break;

    case utf8StringCid:
      os << "utf8String ";
      if (utf8String)
        os << *utf8String;
      else
        os << "-- void3 --\n";
      break;

  } // end of switch
#endif /* NDEBUG */
} // ESSPrivacyMark::Print

SecurityCategory::SecurityCategory()
{
}

SecurityCategory::SecurityCategory (const SecurityCategory &)
{
  Asn1Error << "use of incompletely defined SecurityCategory::SecurityCategory (const SecurityCategory &)" << endl;
  abort();
}

SecurityCategory::~SecurityCategory()
{
}

AsnType *SecurityCategory::Clone() const
{
  return new SecurityCategory;
}

AsnType *SecurityCategory::Copy() const
{
  return new SecurityCategory (*this);
}

#if SNACC_DEEP_COPY
SecurityCategory &SecurityCategory::operator = (const SecurityCategory &that)
#else // SNACC_DEEP_COPY
SecurityCategory &SecurityCategory::operator = (const SecurityCategory &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    type = that.type;
    value = that.value;
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined SecurityCategory &SecurityCategory::operator = (const SecurityCategory &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
SecurityCategory::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

      BEncEocIfNec (b);
        ENC_LOAD_ANYBUF(&value, b, l);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 1);
    totalLen += l;

    l = type.BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, CNTX, PRIM, 0);
    totalLen += l;

  return totalLen;
} // SecurityCategory::BEncContent


void SecurityCategory::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    type.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    SnaccExcep::throwMe(-111);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
        DEC_LOAD_ANYBUF(&value, b, seqBytesDecoded, env);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (b, seqBytesDecoded, env);

  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    SnaccExcep::throwMe(-112);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << endl;
    SnaccExcep::throwMe(-113);
  }
  else
    return;
} // SecurityCategory::BDecContent

AsnLen SecurityCategory::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void SecurityCategory::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "SecurityCategory::BDec: ERROR - wrong tag" << endl;
    SnaccExcep::throwMe(-114);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

void SecurityCategory::Print (ostream &os) const
{
#ifndef NDEBUG
  os << "{ -- SEQUENCE --" << endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "type ";
    os << type;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "value ";
    os << value;
  }

  os << endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
#endif /* NDEBUG */
} // SecurityCategory::Print


EntityIdentifier::EntityIdentifier()
{
  choiceId = issuerAndSerialNumberCid;
#if TCL
  issuerAndSerialNumber = new IssuerAndSerialNumber;
#else
  issuerAndSerialNumber = NULL; // incomplete initialization of mandatory element!
#endif // TCL
}

EntityIdentifier::EntityIdentifier (const EntityIdentifier &)
{
  Asn1Error << "use of incompletely defined EntityIdentifier::EntityIdentifier (const EntityIdentifier &)" << endl;
  abort();
}

EntityIdentifier::~EntityIdentifier()
{
  switch (choiceId)
  {
    case issuerAndSerialNumberCid:
      delete issuerAndSerialNumber;
      break;
    case subjectKeyIdentifierCid:
      delete subjectKeyIdentifier;
      break;
  } // end of switch
} // end of destructor

AsnType *EntityIdentifier::Clone() const
{
  return new EntityIdentifier;
}

AsnType *EntityIdentifier::Copy() const
{
  return new EntityIdentifier (*this);
}

#if SNACC_DEEP_COPY
EntityIdentifier &EntityIdentifier::operator = (const EntityIdentifier &that)
#else // SNACC_DEEP_COPY
EntityIdentifier &EntityIdentifier::operator = (const EntityIdentifier &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    switch (choiceId)
    {
      case issuerAndSerialNumberCid:
        delete issuerAndSerialNumber;
        break;
      case subjectKeyIdentifierCid:
        delete subjectKeyIdentifier;
        break;
    }
    switch (choiceId = that.choiceId)
    {
      case issuerAndSerialNumberCid:
        issuerAndSerialNumber = new IssuerAndSerialNumber;
        *issuerAndSerialNumber = *that.issuerAndSerialNumber;
        break;
      case subjectKeyIdentifierCid:
        subjectKeyIdentifier = new KeyIdentifier;
        *subjectKeyIdentifier = *that.subjectKeyIdentifier;
        break;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined EntityIdentifier &EntityIdentifier::operator = (const EntityIdentifier &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
EntityIdentifier::BEncContent (BUF_TYPE b)
{
  AsnLen l;
  switch (choiceId)
  {
    case issuerAndSerialNumberCid:
      BEncEocIfNec (b);
      l = issuerAndSerialNumber->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
      break;

    case subjectKeyIdentifierCid:
      l = subjectKeyIdentifier->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
      break;

  } // end switch
  return l;
} // EntityIdentifier::BEncContent


void EntityIdentifier::BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  switch (tag)
  {
    case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
      choiceId = issuerAndSerialNumberCid;
      issuerAndSerialNumber = new IssuerAndSerialNumber;
        issuerAndSerialNumber->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE):
    case MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE):
      choiceId = subjectKeyIdentifierCid;
      subjectKeyIdentifier = new KeyIdentifier;
        subjectKeyIdentifier->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    default:
      Asn1Error << "ERROR - unexpected tag in CHOICE" << endl;
      SnaccExcep::throwMe(-115);
      break;
  } // end switch
} // EntityIdentifier::BDecContent


AsnLen EntityIdentifier::BEnc (BUF_TYPE b)
{
    AsnLen l;
    l = BEncContent (b);
    return l;
}

void EntityIdentifier::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnLen elmtLen;
    AsnTag tag;

    /*  CHOICEs are a special case - grab identifying tag */
    /*  this allows easier handling of nested CHOICEs */
    tag = BDecTag (b, bytesDecoded, env);
    elmtLen = BDecLen (b, bytesDecoded, env);
    BDecContent (b, tag, elmtLen, bytesDecoded, env);
}

void EntityIdentifier::Print (ostream &os) const
{
#ifndef NDEBUG
  switch (choiceId)
  {
    case issuerAndSerialNumberCid:
      os << "issuerAndSerialNumber ";
      if (issuerAndSerialNumber)
        os << *issuerAndSerialNumber;
      else
        os << "-- void3 --\n";
      break;

    case subjectKeyIdentifierCid:
      os << "subjectKeyIdentifier ";
      if (subjectKeyIdentifier)
        os << *subjectKeyIdentifier;
      else
        os << "-- void3 --\n";
      break;

  } // end of switch
#endif /* NDEBUG */
} // EntityIdentifier::Print

ReceiptsFrom::ReceiptsFrom()
{
  choiceId = allOrFirstTierCid;
#if TCL
  allOrFirstTier = new AllOrFirstTier;
#else
  allOrFirstTier = NULL; // incomplete initialization of mandatory element!
#endif // TCL
}

ReceiptsFrom::ReceiptsFrom (const ReceiptsFrom &)
{
  Asn1Error << "use of incompletely defined ReceiptsFrom::ReceiptsFrom (const ReceiptsFrom &)" << endl;
  abort();
}

ReceiptsFrom::~ReceiptsFrom()
{
  switch (choiceId)
  {
    case allOrFirstTierCid:
      delete allOrFirstTier;
      break;
    case receiptListCid:
      delete receiptList;
      break;
  } // end of switch
} // end of destructor

AsnType *ReceiptsFrom::Clone() const
{
  return new ReceiptsFrom;
}

AsnType *ReceiptsFrom::Copy() const
{
  return new ReceiptsFrom (*this);
}

#if SNACC_DEEP_COPY
ReceiptsFrom &ReceiptsFrom::operator = (const ReceiptsFrom &that)
#else // SNACC_DEEP_COPY
ReceiptsFrom &ReceiptsFrom::operator = (const ReceiptsFrom &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    switch (choiceId)
    {
      case allOrFirstTierCid:
        delete allOrFirstTier;
        break;
      case receiptListCid:
        delete receiptList;
        break;
    }
    switch (choiceId = that.choiceId)
    {
      case allOrFirstTierCid:
        allOrFirstTier = new AllOrFirstTier;
        *allOrFirstTier = *that.allOrFirstTier;
        break;
      case receiptListCid:
        receiptList = new ReceiptsFromSeqOf;
        *receiptList = *that.receiptList;
        break;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined ReceiptsFrom &ReceiptsFrom::operator = (const ReceiptsFrom &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
ReceiptsFrom::BEncContent (BUF_TYPE b)
{
  AsnLen l;
  switch (choiceId)
  {
    case allOrFirstTierCid:
      l = allOrFirstTier->BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, CNTX, PRIM, 0);
      break;

    case receiptListCid:
      BEncEocIfNec (b);
      l = receiptList->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 1);
      break;

  } // end switch
  return l;
} // ReceiptsFrom::BEncContent


void ReceiptsFrom::BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  switch (tag)
  {
    case MAKE_TAG_ID (CNTX, PRIM, 0):
      choiceId = allOrFirstTierCid;
      allOrFirstTier = new AllOrFirstTier;
        allOrFirstTier->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 1):
      choiceId = receiptListCid;
      receiptList = new ReceiptsFromSeqOf;
        receiptList->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    default:
      Asn1Error << "ERROR - unexpected tag in CHOICE" << endl;
      SnaccExcep::throwMe(-116);
      break;
  } // end switch
} // ReceiptsFrom::BDecContent


AsnLen ReceiptsFrom::BEnc (BUF_TYPE b)
{
    AsnLen l;
    l = BEncContent (b);
    return l;
}

void ReceiptsFrom::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnLen elmtLen;
    AsnTag tag;

    /*  CHOICEs are a special case - grab identifying tag */
    /*  this allows easier handling of nested CHOICEs */
    tag = BDecTag (b, bytesDecoded, env);
    elmtLen = BDecLen (b, bytesDecoded, env);
    BDecContent (b, tag, elmtLen, bytesDecoded, env);
}

void ReceiptsFrom::Print (ostream &os) const
{
#ifndef NDEBUG
  switch (choiceId)
  {
    case allOrFirstTierCid:
      os << "allOrFirstTier ";
      if (allOrFirstTier)
        os << *allOrFirstTier;
      else
        os << "-- void3 --\n";
      break;

    case receiptListCid:
      os << "receiptList ";
      if (receiptList)
        os << *receiptList;
      else
        os << "-- void3 --\n";
      break;

  } // end of switch
#endif /* NDEBUG */
} // ReceiptsFrom::Print

AsnType *SecurityCategories::Clone() const
{
  return new SecurityCategories;
}

AsnType *SecurityCategories::Copy() const
{
  return new SecurityCategories (*this);
}

AsnLen SecurityCategories::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SET_TAG_CODE);
  return l;
}

void SecurityCategories::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SET_TAG_CODE))
  {
    Asn1Error << "SecurityCategories::BDec: ERROR - wrong tag" << endl;
    SnaccExcep::throwMe(-117);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

SecurityCategories::SecurityCategories (const SecurityCategories &)
{
  Asn1Error << "use of incompletely defined SecurityCategories::SecurityCategories (const SecurityCategories &)" << endl;
  abort();
}

SecurityCategories::~SecurityCategories()
{
  SetCurrToFirst();
  for (; Curr() != NULL; RemoveCurrFromList())
    ;
} // end of destructor

#if SNACC_DEEP_COPY
SecurityCategories &SecurityCategories::operator = (const SecurityCategories &that)
#else // SNACC_DEEP_COPY
SecurityCategories &SecurityCategories::operator = (const SecurityCategories &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    SetCurrToFirst();
    for (; Curr(); RemoveCurrFromList())
      ;

    //that.SetCurrToFirst();
    //for (; that.Curr(); that.GoNext())
    //  AppendCopy (*that.Curr());
    for (const AsnListElmt *run=that.first; run; run=run->next)
      AppendCopy (*run->elmt);
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined SecurityCategories &SecurityCategories::operator = (const SecurityCategories &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

void SecurityCategories::Print (ostream &os) const
{
#ifndef NDEBUG
    os << "{ -- SEQUENCE/SET OF -- " << endl;
    indentG += stdIndentG;
    //SetCurrToFirst();
    //for (; Curr() != NULL; GoNext())
    for (const AsnListElmt *run=first; run; run=run->next)
    {
        Indent (os, indentG);
        //os << *Curr();
        os << *run->elmt;
        //if (Curr() != Last())
        if (run != last)
            os << ",";
        os << endl;
    }
    indentG -= stdIndentG;
    Indent (os, indentG);
    os << "}\n";
#endif /* NDEBUG */


} // Print


void  SecurityCategories::SetCurrElmt (unsigned long int index)
{
  unsigned long int i;
  curr = first;
  if (count)
    for (i = 0; (i < (count-1)) && (i < index); i++)
      curr = curr->next;
} // SecurityCategories::SetCurrElmt


unsigned long int  SecurityCategories::GetCurrElmtIndex()
{
    unsigned long int i;
    AsnListElmt *tmp;
    if (curr != NULL)
    {
        for (i = 0, tmp = first; tmp != NULL; i++)
        {
            if (tmp == curr)
                return i;
            else
                tmp = tmp->next;
        }
    }
    return count;
} // SecurityCategories::GetCurrElmtIndex


// alloc new list elmt, put at end of list
//  and return the component type
SecurityCategory *SecurityCategories::Append()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new SecurityCategory;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // SecurityCategories::Append


// alloc new list elmt, put at begining of list
//  and return the component type
SecurityCategory  *SecurityCategories::Prepend()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new SecurityCategory;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // SecurityCategories::Prepend


// alloc new list elmt, insert it before the
// current element and return the component type
// if the current element is null, the new element
// is placed at the beginning of the list.
SecurityCategory  *SecurityCategories::InsertBefore()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new SecurityCategory;
    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // SecurityCategories::InsertBefore


// alloc new list elmt, insert it after the
// current element and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
SecurityCategory *SecurityCategories::InsertAfter()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new SecurityCategory;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // SecurityCategories::InsertAfter


SecurityCategories  &SecurityCategories::AppendCopy (SecurityCategory &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new SecurityCategory;
    *newElmt->elmt = elmt;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return *this;
} // AppendCopy


SecurityCategories  &SecurityCategories::PrependCopy (SecurityCategory &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new SecurityCategory;
    *newElmt->elmt = elmt;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return *this;
} // SecurityCategories::PrependCopy


// alloc new list elmt, insert it before the
// current element, copy the given elmt into the new elmt
// and return the component type.
// if the current element is null, the new element
// is placed at the beginning of the list.
SecurityCategories &SecurityCategories::InsertBeforeAndCopy (SecurityCategory &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new SecurityCategory;
    *newElmt->elmt = elmt;

    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return *this;
} // SecurityCategories::InsertBeforeAndCopy


// alloc new list elmt, insert it after the
// current element, copy given elmt in to new elmt
//  and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
SecurityCategories  &SecurityCategories::InsertAfterAndCopy (SecurityCategory &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new SecurityCategory;
    *newElmt->elmt = elmt;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return *this;
} // SecurityCategories::InsertAfterAndCopy


// remove current element from list if current element is not NULL 
// The new current element will be the next element.
// If the current element is the last element in the list
// the second but last element will become the new current element.
void SecurityCategories::RemoveCurrFromList()
{
    AsnListElmt *del_elmt;

    if (curr != NULL)
    {
        del_elmt = curr;
        count--;

        if (count == 0)
            first = last = curr = NULL;
        else if (curr == first)
        {
            curr = first= first->next;
            first->prev = NULL;
        }
        else if (curr == last)
        {
            curr = last = last->prev;
            last->next = NULL;
        }
        else
        {
            curr->prev->next = curr->next;
            curr->next->prev = curr->prev;
        }

        delete del_elmt->elmt;
        delete del_elmt;
    }
}


AsnLen SecurityCategories::BEncContent (BUF_TYPE b)
{
    AsnListElmt *currElmt;
    AsnLen elmtLen;
    AsnLen totalLen = 0;
    {
      int iii,icount;
      CSM_Buffer **tmpEnc=NULL;
      for (currElmt = last,icount=0; currElmt != NULL; currElmt = currElmt->prev, icount++);
      tmpEnc = (CSM_Buffer **) calloc(sizeof(CSM_Buffer *), icount);
      for (currElmt = last, iii=0; currElmt != NULL; currElmt = currElmt->prev,iii++,elmtLen=0)
      {
      BEncEocIfNec (b);
        ENCODE_BUF1(currElmt->elmt->BEncContent, elmtLen);
    elmtLen += BEncConsLen (outputBuf, elmtLen);

    elmtLen += BEncTag1 (outputBuf, UNIV, CONS, SEQ_TAG_CODE);
        ENCODE_BUF2(tmpEnc[iii]);
      }
      vdasnacc_sortSetOf(tmpEnc, icount);
      for (iii=0,elmtLen=0; iii < icount; elmtLen+=tmpEnc[iii++]->Length())
            SM_WriteToAsnBuf(tmpEnc[iii], b);
      for (iii=0; iii < icount; iii++) delete tmpEnc[iii];
       free(tmpEnc);
    }
        totalLen += elmtLen;
    return totalLen;
} // SecurityCategories::BEncContent


void  SecurityCategories::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0,
                                  AsnLen &bytesDecoded, ENV_TYPE env)
{
    SecurityCategory *listElmt;
    AsnTag tag1;
    AsnLen listBytesDecoded = 0;
    AsnLen elmtLen1;

    while ((listBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN))
    {
        tag1 = BDecTag (b, listBytesDecoded, env);
        if ((tag1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
        {
            BDEC_2ND_EOC_OCTET (b, listBytesDecoded, env);
            break;
        }
        if ((tag1 != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
        {
            Asn1Error << "Unexpected Tag" << endl;
            SnaccExcep::throwMe(-118);
        }

        elmtLen1 = BDecLen (b, listBytesDecoded, env);
        listElmt = Append();
        listElmt->BDecContent (b, tag1, elmtLen1, listBytesDecoded, env);
    }

    bytesDecoded += listBytesDecoded;
} // SecurityCategories::BDecContent


MLReceiptPolicy::MLReceiptPolicy()
{
  choiceId = noneCid;
#if TCL
  none = new AsnNull;
#else
  none = NULL; // incomplete initialization of mandatory element!
#endif // TCL
}

MLReceiptPolicy::MLReceiptPolicy (const MLReceiptPolicy &)
{
  Asn1Error << "use of incompletely defined MLReceiptPolicy::MLReceiptPolicy (const MLReceiptPolicy &)" << endl;
  abort();
}

MLReceiptPolicy::~MLReceiptPolicy()
{
  switch (choiceId)
  {
    case noneCid:
      delete none;
      break;
    case insteadOfCid:
      delete insteadOf;
      break;
    case inAdditionToCid:
      delete inAdditionTo;
      break;
  } // end of switch
} // end of destructor

AsnType *MLReceiptPolicy::Clone() const
{
  return new MLReceiptPolicy;
}

AsnType *MLReceiptPolicy::Copy() const
{
  return new MLReceiptPolicy (*this);
}

#if SNACC_DEEP_COPY
MLReceiptPolicy &MLReceiptPolicy::operator = (const MLReceiptPolicy &that)
#else // SNACC_DEEP_COPY
MLReceiptPolicy &MLReceiptPolicy::operator = (const MLReceiptPolicy &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    switch (choiceId)
    {
      case noneCid:
        delete none;
        break;
      case insteadOfCid:
        delete insteadOf;
        break;
      case inAdditionToCid:
        delete inAdditionTo;
        break;
    }
    switch (choiceId = that.choiceId)
    {
      case noneCid:
        none = new AsnNull;
        *none = *that.none;
        break;
      case insteadOfCid:
        insteadOf = new MLReceiptPolicySeqOf;
        *insteadOf = *that.insteadOf;
        break;
      case inAdditionToCid:
        inAdditionTo = new MLReceiptPolicySeqOf1;
        *inAdditionTo = *that.inAdditionTo;
        break;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined MLReceiptPolicy &MLReceiptPolicy::operator = (const MLReceiptPolicy &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
MLReceiptPolicy::BEncContent (BUF_TYPE b)
{
  AsnLen l;
  switch (choiceId)
  {
    case noneCid:
      l = none->BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, CNTX, PRIM, 0);
      break;

    case insteadOfCid:
      BEncEocIfNec (b);
      l = insteadOf->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 1);
      break;

    case inAdditionToCid:
      BEncEocIfNec (b);
      l = inAdditionTo->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, CNTX, CONS, 2);
      break;

  } // end switch
  return l;
} // MLReceiptPolicy::BEncContent


void MLReceiptPolicy::BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  switch (tag)
  {
    case MAKE_TAG_ID (CNTX, PRIM, 0):
      choiceId = noneCid;
      none = new AsnNull;
        none->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 1):
      choiceId = insteadOfCid;
      insteadOf = new MLReceiptPolicySeqOf;
        insteadOf->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 2):
      choiceId = inAdditionToCid;
      inAdditionTo = new MLReceiptPolicySeqOf1;
        inAdditionTo->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    default:
      Asn1Error << "ERROR - unexpected tag in CHOICE" << endl;
      SnaccExcep::throwMe(-119);
      break;
  } // end switch
} // MLReceiptPolicy::BDecContent


AsnLen MLReceiptPolicy::BEnc (BUF_TYPE b)
{
    AsnLen l;
    l = BEncContent (b);
    return l;
}

void MLReceiptPolicy::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnLen elmtLen;
    AsnTag tag;

    /*  CHOICEs are a special case - grab identifying tag */
    /*  this allows easier handling of nested CHOICEs */
    tag = BDecTag (b, bytesDecoded, env);
    elmtLen = BDecLen (b, bytesDecoded, env);
    BDecContent (b, tag, elmtLen, bytesDecoded, env);
}

void MLReceiptPolicy::Print (ostream &os) const
{
#ifndef NDEBUG
  switch (choiceId)
  {
    case noneCid:
      os << "none ";
      if (none)
        os << *none;
      else
        os << "-- void3 --\n";
      break;

    case insteadOfCid:
      os << "insteadOf ";
      if (insteadOf)
        os << *insteadOf;
      else
        os << "-- void3 --\n";
      break;

    case inAdditionToCid:
      os << "inAdditionTo ";
      if (inAdditionTo)
        os << *inAdditionTo;
      else
        os << "-- void3 --\n";
      break;

  } // end of switch
#endif /* NDEBUG */
} // MLReceiptPolicy::Print

ESSCertID::ESSCertID()
{
  issuerSerial = NULL;
}

ESSCertID::ESSCertID (const ESSCertID &)
{
  Asn1Error << "use of incompletely defined ESSCertID::ESSCertID (const ESSCertID &)" << endl;
  abort();
}

ESSCertID::~ESSCertID()
{
  delete issuerSerial;
}

AsnType *ESSCertID::Clone() const
{
  return new ESSCertID;
}

AsnType *ESSCertID::Copy() const
{
  return new ESSCertID (*this);
}

#if SNACC_DEEP_COPY
ESSCertID &ESSCertID::operator = (const ESSCertID &that)
#else // SNACC_DEEP_COPY
ESSCertID &ESSCertID::operator = (const ESSCertID &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    certHash = that.certHash;
    if (that.issuerSerial)
    {
      if (!issuerSerial)
        issuerSerial = new IssuerSerial;
      *issuerSerial = *that.issuerSerial;
    }
    else
    {
      delete issuerSerial;
      issuerSerial = NULL;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined ESSCertID &ESSCertID::operator = (const ESSCertID &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
ESSCertID::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

  if (NOT_NULL (issuerSerial))
  {
      BEncEocIfNec (b);
    l = issuerSerial->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;
  }

    l = certHash.BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
    totalLen += l;

  return totalLen;
} // ESSCertID::BEncContent


void ESSCertID::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    certHash.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    SnaccExcep::throwMe(-120);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    issuerSerial = new IssuerSerial;
    issuerSerial->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << endl;
    SnaccExcep::throwMe(-121);
  }
  else
    return;
} // ESSCertID::BDecContent

AsnLen ESSCertID::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void ESSCertID::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "ESSCertID::BDec: ERROR - wrong tag" << endl;
    SnaccExcep::throwMe(-122);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

void ESSCertID::Print (ostream &os) const
{
#ifndef NDEBUG
  os << "{ -- SEQUENCE --" << endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "certHash ";
    os << certHash;
    os << "," << endl;
  }

  if (NOT_NULL (issuerSerial))
  {
    os << ","<< endl;
    Indent (os, indentG);
    os << "issuerSerial ";
    os << *issuerSerial;
  }
  else
  {
    Indent (os, indentG);
    os << "issuerSerial ";
    os << "-- void --";
    os << endl;
  }

  os << endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
#endif /* NDEBUG */
} // ESSCertID::Print


AsnType *SigningCertificateSeqOf::Clone() const
{
  return new SigningCertificateSeqOf;
}

AsnType *SigningCertificateSeqOf::Copy() const
{
  return new SigningCertificateSeqOf (*this);
}

AsnLen SigningCertificateSeqOf::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void SigningCertificateSeqOf::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "SigningCertificateSeqOf::BDec: ERROR - wrong tag" << endl;
    SnaccExcep::throwMe(-123);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

SigningCertificateSeqOf::SigningCertificateSeqOf (const SigningCertificateSeqOf &)
{
  Asn1Error << "use of incompletely defined SigningCertificateSeqOf::SigningCertificateSeqOf (const SigningCertificateSeqOf &)" << endl;
  abort();
}

SigningCertificateSeqOf::~SigningCertificateSeqOf()
{
  SetCurrToFirst();
  for (; Curr() != NULL; RemoveCurrFromList())
    ;
} // end of destructor

#if SNACC_DEEP_COPY
SigningCertificateSeqOf &SigningCertificateSeqOf::operator = (const SigningCertificateSeqOf &that)
#else // SNACC_DEEP_COPY
SigningCertificateSeqOf &SigningCertificateSeqOf::operator = (const SigningCertificateSeqOf &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    SetCurrToFirst();
    for (; Curr(); RemoveCurrFromList())
      ;

    //that.SetCurrToFirst();
    //for (; that.Curr(); that.GoNext())
    //  AppendCopy (*that.Curr());
    for (const AsnListElmt *run=that.first; run; run=run->next)
      AppendCopy (*run->elmt);
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined SigningCertificateSeqOf &SigningCertificateSeqOf::operator = (const SigningCertificateSeqOf &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

void SigningCertificateSeqOf::Print (ostream &os) const
{
#ifndef NDEBUG
    os << "{ -- SEQUENCE/SET OF -- " << endl;
    indentG += stdIndentG;
    //SetCurrToFirst();
    //for (; Curr() != NULL; GoNext())
    for (const AsnListElmt *run=first; run; run=run->next)
    {
        Indent (os, indentG);
        //os << *Curr();
        os << *run->elmt;
        //if (Curr() != Last())
        if (run != last)
            os << ",";
        os << endl;
    }
    indentG -= stdIndentG;
    Indent (os, indentG);
    os << "}\n";
#endif /* NDEBUG */


} // Print


void  SigningCertificateSeqOf::SetCurrElmt (unsigned long int index)
{
  unsigned long int i;
  curr = first;
  if (count)
    for (i = 0; (i < (count-1)) && (i < index); i++)
      curr = curr->next;
} // SigningCertificateSeqOf::SetCurrElmt


unsigned long int  SigningCertificateSeqOf::GetCurrElmtIndex()
{
    unsigned long int i;
    AsnListElmt *tmp;
    if (curr != NULL)
    {
        for (i = 0, tmp = first; tmp != NULL; i++)
        {
            if (tmp == curr)
                return i;
            else
                tmp = tmp->next;
        }
    }
    return count;
} // SigningCertificateSeqOf::GetCurrElmtIndex


// alloc new list elmt, put at end of list
//  and return the component type
ESSCertID *SigningCertificateSeqOf::Append()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new ESSCertID;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // SigningCertificateSeqOf::Append


// alloc new list elmt, put at begining of list
//  and return the component type
ESSCertID  *SigningCertificateSeqOf::Prepend()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new ESSCertID;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // SigningCertificateSeqOf::Prepend


// alloc new list elmt, insert it before the
// current element and return the component type
// if the current element is null, the new element
// is placed at the beginning of the list.
ESSCertID  *SigningCertificateSeqOf::InsertBefore()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new ESSCertID;
    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // SigningCertificateSeqOf::InsertBefore


// alloc new list elmt, insert it after the
// current element and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
ESSCertID *SigningCertificateSeqOf::InsertAfter()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new ESSCertID;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // SigningCertificateSeqOf::InsertAfter


SigningCertificateSeqOf  &SigningCertificateSeqOf::AppendCopy (ESSCertID &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new ESSCertID;
    *newElmt->elmt = elmt;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return *this;
} // AppendCopy


SigningCertificateSeqOf  &SigningCertificateSeqOf::PrependCopy (ESSCertID &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new ESSCertID;
    *newElmt->elmt = elmt;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return *this;
} // SigningCertificateSeqOf::PrependCopy


// alloc new list elmt, insert it before the
// current element, copy the given elmt into the new elmt
// and return the component type.
// if the current element is null, the new element
// is placed at the beginning of the list.
SigningCertificateSeqOf &SigningCertificateSeqOf::InsertBeforeAndCopy (ESSCertID &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new ESSCertID;
    *newElmt->elmt = elmt;

    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return *this;
} // SigningCertificateSeqOf::InsertBeforeAndCopy


// alloc new list elmt, insert it after the
// current element, copy given elmt in to new elmt
//  and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
SigningCertificateSeqOf  &SigningCertificateSeqOf::InsertAfterAndCopy (ESSCertID &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new ESSCertID;
    *newElmt->elmt = elmt;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return *this;
} // SigningCertificateSeqOf::InsertAfterAndCopy


// remove current element from list if current element is not NULL 
// The new current element will be the next element.
// If the current element is the last element in the list
// the second but last element will become the new current element.
void SigningCertificateSeqOf::RemoveCurrFromList()
{
    AsnListElmt *del_elmt;

    if (curr != NULL)
    {
        del_elmt = curr;
        count--;

        if (count == 0)
            first = last = curr = NULL;
        else if (curr == first)
        {
            curr = first= first->next;
            first->prev = NULL;
        }
        else if (curr == last)
        {
            curr = last = last->prev;
            last->next = NULL;
        }
        else
        {
            curr->prev->next = curr->next;
            curr->next->prev = curr->prev;
        }

        delete del_elmt->elmt;
        delete del_elmt;
    }
}


AsnLen SigningCertificateSeqOf::BEncContent (BUF_TYPE b)
{
    AsnListElmt *currElmt;
    AsnLen elmtLen;
    AsnLen totalLen = 0;
    for (currElmt = last; currElmt != NULL; currElmt = currElmt->prev)
    {
      BEncEocIfNec (b);
        elmtLen = currElmt->elmt->BEncContent (b);
    elmtLen += BEncConsLen (b, elmtLen);

    elmtLen += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
        totalLen += elmtLen;
    }
    return totalLen;
} // SigningCertificateSeqOf::BEncContent


void  SigningCertificateSeqOf::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0,
                                  AsnLen &bytesDecoded, ENV_TYPE env)
{
    ESSCertID *listElmt;
    AsnTag tag1;
    AsnLen listBytesDecoded = 0;
    AsnLen elmtLen1;

    while ((listBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN))
    {
        tag1 = BDecTag (b, listBytesDecoded, env);
        if ((tag1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
        {
            BDEC_2ND_EOC_OCTET (b, listBytesDecoded, env);
            break;
        }
        if ((tag1 != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
        {
            Asn1Error << "Unexpected Tag" << endl;
            SnaccExcep::throwMe(-124);
        }

        elmtLen1 = BDecLen (b, listBytesDecoded, env);
        listElmt = Append();
        listElmt->BDecContent (b, tag1, elmtLen1, listBytesDecoded, env);
    }

    bytesDecoded += listBytesDecoded;
} // SigningCertificateSeqOf::BDecContent


ESSSecurityLabel::ESSSecurityLabel()
{
  security_classification = NULL;
  privacy_mark = NULL;
  security_categories = NULL;
}

ESSSecurityLabel::ESSSecurityLabel (const ESSSecurityLabel &)
{
  Asn1Error << "use of incompletely defined ESSSecurityLabel::ESSSecurityLabel (const ESSSecurityLabel &)" << endl;
  abort();
}

ESSSecurityLabel::~ESSSecurityLabel()
{
  delete security_classification;
  delete privacy_mark;
  delete security_categories;
}

AsnType *ESSSecurityLabel::Clone() const
{
  return new ESSSecurityLabel;
}

AsnType *ESSSecurityLabel::Copy() const
{
  return new ESSSecurityLabel (*this);
}

#if SNACC_DEEP_COPY
ESSSecurityLabel &ESSSecurityLabel::operator = (const ESSSecurityLabel &that)
#else // SNACC_DEEP_COPY
ESSSecurityLabel &ESSSecurityLabel::operator = (const ESSSecurityLabel &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    security_policy_identifier = that.security_policy_identifier;
    if (that.security_classification)
    {
      if (!security_classification)
        security_classification = new SecurityClassification;
      *security_classification = *that.security_classification;
    }
    else
    {
      delete security_classification;
      security_classification = NULL;
    }
    if (that.privacy_mark)
    {
      if (!privacy_mark)
        privacy_mark = new ESSPrivacyMark;
      *privacy_mark = *that.privacy_mark;
    }
    else
    {
      delete privacy_mark;
      privacy_mark = NULL;
    }
    if (that.security_categories)
    {
      if (!security_categories)
        security_categories = new SecurityCategories;
      *security_categories = *that.security_categories;
    }
    else
    {
      delete security_categories;
      security_categories = NULL;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined ESSSecurityLabel &ESSSecurityLabel::operator = (const ESSSecurityLabel &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen ESSSecurityLabel::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

      AsnBuf outputBuf;
       int iii=0, tmpCount=0;
      char *lpszBuf = (char *)calloc(1, 1024);
      outputBuf.Init(lpszBuf, 1024);
      outputBuf.ResetInWriteRvsMode();
      CSM_Buffer *tmpEnc[4];
  if (NOT_NULL (security_categories))
  {
      BEncEocIfNec (b);
    l = security_categories->BEncContent (outputBuf);
    l += BEncConsLen (outputBuf, l);

    l += BEncTag1 (outputBuf, UNIV, CONS, SET_TAG_CODE);
    totalLen += l;
        SNACC_BUFRESET_READ(&outputBuf);
        SM_ReadFromAsnBuf(tmpEnc[iii], outputBuf,outputBuf.DataLen(),NULL);
        SNACC_BUFRESET_WRITE(&outputBuf);
        iii++;
  }

  if (NOT_NULL (privacy_mark))
  {
    l = privacy_mark->BEncContent (outputBuf);
    totalLen += l;
        SNACC_BUFRESET_READ(&outputBuf);
        SM_ReadFromAsnBuf(tmpEnc[iii], outputBuf,outputBuf.DataLen(),NULL);
        SNACC_BUFRESET_WRITE(&outputBuf);
        iii++;
  }

  if (NOT_NULL (security_classification))
  {
    l = security_classification->BEncContent (outputBuf);
    BEncDefLenTo127 (outputBuf, l);
    l++;

    l += BEncTag1 (outputBuf, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;
        SNACC_BUFRESET_READ(&outputBuf);
        SM_ReadFromAsnBuf(tmpEnc[iii], outputBuf,outputBuf.DataLen(),NULL);
        SNACC_BUFRESET_WRITE(&outputBuf);
        iii++;
  }

    l = security_policy_identifier.BEncContent (outputBuf);
    l += BEncDefLen (outputBuf, l);

    l += BEncTag1 (outputBuf, UNIV, PRIM, OID_TAG_CODE);
    totalLen += l;
        SNACC_BUFRESET_READ(&outputBuf);
        SM_ReadFromAsnBuf(tmpEnc[iii], outputBuf,outputBuf.DataLen(),NULL);
        SNACC_BUFRESET_WRITE(&outputBuf);
        iii++;

      vdasnacc_sortSet(tmpEnc, iii);
      tmpCount = iii;  /** REMEMBER how many we have**/
      for (iii=0; iii < tmpCount; iii++)
         SM_WriteToAsnBuf(tmpEnc[iii], b);
      for (iii=0; iii < tmpCount; iii++) delete tmpEnc[iii];
      free(lpszBuf);
  return totalLen;
} // ESSSecurityLabel::BEncContent


void ESSSecurityLabel::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen setBytesDecoded = 0;
  unsigned int mandatoryElmtsDecoded = 0;
  AsnLen elmtLen1;

  for (; (setBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN); )
  {
    tag1 = BDecTag (b, setBytesDecoded, env);

    if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
    {
      BDEC_2ND_EOC_OCTET (b, setBytesDecoded, env)
      break; /* exit for loop */
    }
    elmtLen1 = BDecLen (b, setBytesDecoded, env);
    switch (tag1)
    {
      case MAKE_TAG_ID (UNIV, PRIM, OID_TAG_CODE):
        security_policy_identifier.BDecContent (b, tag1, elmtLen1, setBytesDecoded, env);
          mandatoryElmtsDecoded++;
          break;

      case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
        security_classification = new SecurityClassification;
        security_classification->BDecContent (b, tag1, elmtLen1, setBytesDecoded, env);
          break;

      case MAKE_TAG_ID (UNIV, PRIM, PRINTABLESTRING_TAG_CODE):
      case MAKE_TAG_ID (UNIV, CONS, PRINTABLESTRING_TAG_CODE):
      case MAKE_TAG_ID (UNIV, PRIM, 12):
      case MAKE_TAG_ID (UNIV, CONS, 12):
        privacy_mark = new ESSPrivacyMark;
        privacy_mark->BDecContent (b, tag1, elmtLen1, setBytesDecoded, env);
          break;

      case MAKE_TAG_ID (UNIV, CONS, SET_TAG_CODE):
        security_categories = new SecurityCategories;
        security_categories->BDecContent (b, tag1, elmtLen1, setBytesDecoded, env);
          break;

       default:
         Asn1Error << "Unexpected Tag on SET elmt." << endl;
         SnaccExcep::throwMe(-125);
    } // end switch
  } // end for loop
  bytesDecoded += setBytesDecoded;
  if (mandatoryElmtsDecoded != 1)
  {
     Asn1Error << "ERROR - non-optional SET element missing." << endl;
     SnaccExcep::throwMe(-126);
  }
} // ESSSecurityLabel::BDecContent

AsnLen
ESSSecurityLabel::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SET_TAG_CODE);
  return l;
}

void ESSSecurityLabel::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SET_TAG_CODE))
  {
    Asn1Error << "ESSSecurityLabel::BDec: ERROR - wrong tag" << endl;
    SnaccExcep::throwMe(-127);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

void ESSSecurityLabel::Print (ostream &os) const
{
#ifndef NDEBUG
  os << "{ -- SET --" << endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "security-policy-identifier ";
    os << security_policy_identifier;
  }

  if (NOT_NULL (security_classification))
  {
    os << ","<< endl;
    Indent (os, indentG);
    os << "security-classification ";
    os << *security_classification;
  }
  else
    os << "-- void2 --\n";

  if (NOT_NULL (privacy_mark))
  {
    os << ","<< endl;
    Indent (os, indentG);
    os << "privacy-mark ";
    os << *privacy_mark;
  }
  else
    os << "-- void2 --\n";

  if (NOT_NULL (security_categories))
  {
    os << ","<< endl;
    Indent (os, indentG);
    os << "security-categories ";
    os << *security_categories;
  }
  else
    os << "-- void2 --\n";

  os << endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
#endif /* NDEBUG */
} // ESSSecurityLabel - operator <<


MLData::MLData()
{
#if TCL
  mailListIdentifier = new EntityIdentifier;
#else
  mailListIdentifier = NULL; // incomplete initialization of mandatory element!
#endif // TCL
  mlReceiptPolicy = NULL;
}

MLData::MLData (const MLData &)
{
  Asn1Error << "use of incompletely defined MLData::MLData (const MLData &)" << endl;
  abort();
}

MLData::~MLData()
{
  delete mailListIdentifier;
  delete mlReceiptPolicy;
}

AsnType *MLData::Clone() const
{
  return new MLData;
}

AsnType *MLData::Copy() const
{
  return new MLData (*this);
}

#if SNACC_DEEP_COPY
MLData &MLData::operator = (const MLData &that)
#else // SNACC_DEEP_COPY
MLData &MLData::operator = (const MLData &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    if (that.mailListIdentifier)
    {
      if (!mailListIdentifier)
        mailListIdentifier = new EntityIdentifier;
      *mailListIdentifier = *that.mailListIdentifier;
    }
    else
    {
      delete mailListIdentifier;
      mailListIdentifier = NULL;
    }
    expansionTime = that.expansionTime;
    if (that.mlReceiptPolicy)
    {
      if (!mlReceiptPolicy)
        mlReceiptPolicy = new MLReceiptPolicy;
      *mlReceiptPolicy = *that.mlReceiptPolicy;
    }
    else
    {
      delete mlReceiptPolicy;
      mlReceiptPolicy = NULL;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined MLData &MLData::operator = (const MLData &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
MLData::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

  if (NOT_NULL (mlReceiptPolicy))
  {
    l = mlReceiptPolicy->BEncContent (b);
    totalLen += l;
  }

    l = expansionTime.BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, UNIV, PRIM, GENERALIZEDTIME_TAG_CODE);
    totalLen += l;

    l = mailListIdentifier->BEncContent (b);
    totalLen += l;

  return totalLen;
} // MLData::BEncContent


void MLData::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    mailListIdentifier = new EntityIdentifier;
    mailListIdentifier->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    SnaccExcep::throwMe(-128);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, GENERALIZEDTIME_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, GENERALIZEDTIME_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    expansionTime.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    SnaccExcep::throwMe(-129);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 1))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    mlReceiptPolicy = new MLReceiptPolicy;
    mlReceiptPolicy->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << endl;
    SnaccExcep::throwMe(-130);
  }
  else
    return;
} // MLData::BDecContent

AsnLen MLData::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void MLData::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "MLData::BDec: ERROR - wrong tag" << endl;
    SnaccExcep::throwMe(-131);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

void MLData::Print (ostream &os) const
{
#ifndef NDEBUG
  os << "{ -- SEQUENCE --" << endl;
  indentG += stdIndentG;

  if (NOT_NULL (mailListIdentifier))
  {
    Indent (os, indentG);
    os << "mailListIdentifier ";
    os << *mailListIdentifier;
  }
  else
  {
    Indent (os, indentG);
    os << "mailListIdentifier ";
    os << "-- void --";
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "expansionTime ";
    os << expansionTime;
    os << "," << endl;
  }

  if (NOT_NULL (mlReceiptPolicy))
  {
    os << ","<< endl;
    Indent (os, indentG);
    os << "mlReceiptPolicy ";
    os << *mlReceiptPolicy;
  }
  else
  {
    Indent (os, indentG);
    os << "mlReceiptPolicy ";
    os << "-- void --";
    os << endl;
  }

  os << endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
#endif /* NDEBUG */
} // MLData::Print


ReceiptRequest::ReceiptRequest()
{
#if TCL
  receiptsFrom = new ReceiptsFrom;
#else
  receiptsFrom = NULL; // incomplete initialization of mandatory element!
#endif // TCL
}

ReceiptRequest::ReceiptRequest (const ReceiptRequest &)
{
  Asn1Error << "use of incompletely defined ReceiptRequest::ReceiptRequest (const ReceiptRequest &)" << endl;
  abort();
}

ReceiptRequest::~ReceiptRequest()
{
  delete receiptsFrom;
}

AsnType *ReceiptRequest::Clone() const
{
  return new ReceiptRequest;
}

AsnType *ReceiptRequest::Copy() const
{
  return new ReceiptRequest (*this);
}

#if SNACC_DEEP_COPY
ReceiptRequest &ReceiptRequest::operator = (const ReceiptRequest &that)
#else // SNACC_DEEP_COPY
ReceiptRequest &ReceiptRequest::operator = (const ReceiptRequest &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    signedContentIdentifier = that.signedContentIdentifier;
    if (that.receiptsFrom)
    {
      if (!receiptsFrom)
        receiptsFrom = new ReceiptsFrom;
      *receiptsFrom = *that.receiptsFrom;
    }
    else
    {
      delete receiptsFrom;
      receiptsFrom = NULL;
    }
    receiptsTo = that.receiptsTo;
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined ReceiptRequest &ReceiptRequest::operator = (const ReceiptRequest &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
ReceiptRequest::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

      BEncEocIfNec (b);
    l = receiptsTo.BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;

    l = receiptsFrom->BEncContent (b);
    totalLen += l;

    l = signedContentIdentifier.BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
    totalLen += l;

  return totalLen;
} // ReceiptRequest::BEncContent


void ReceiptRequest::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    signedContentIdentifier.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    SnaccExcep::throwMe(-132);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 0))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    receiptsFrom = new ReceiptsFrom;
    receiptsFrom->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    SnaccExcep::throwMe(-133);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    receiptsTo.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    SnaccExcep::throwMe(-134);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << endl;
    SnaccExcep::throwMe(-135);
  }
  else
    return;
} // ReceiptRequest::BDecContent

AsnLen ReceiptRequest::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void ReceiptRequest::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "ReceiptRequest::BDec: ERROR - wrong tag" << endl;
    SnaccExcep::throwMe(-136);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

void ReceiptRequest::Print (ostream &os) const
{
#ifndef NDEBUG
  os << "{ -- SEQUENCE --" << endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "signedContentIdentifier ";
    os << signedContentIdentifier;
    os << "," << endl;
  }

  if (NOT_NULL (receiptsFrom))
  {
    Indent (os, indentG);
    os << "receiptsFrom ";
    os << *receiptsFrom;
  }
  else
  {
    Indent (os, indentG);
    os << "receiptsFrom ";
    os << "-- void --";
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "receiptsTo ";
    os << receiptsTo;
  }

  os << endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
#endif /* NDEBUG */
} // ReceiptRequest::Print


Receipt::Receipt()
{
}

Receipt::Receipt (const Receipt &)
{
  Asn1Error << "use of incompletely defined Receipt::Receipt (const Receipt &)" << endl;
  abort();
}

Receipt::~Receipt()
{
}

AsnType *Receipt::Clone() const
{
  return new Receipt;
}

AsnType *Receipt::Copy() const
{
  return new Receipt (*this);
}

#if SNACC_DEEP_COPY
Receipt &Receipt::operator = (const Receipt &that)
#else // SNACC_DEEP_COPY
Receipt &Receipt::operator = (const Receipt &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    version = that.version;
    contentType = that.contentType;
    signedContentIdentifier = that.signedContentIdentifier;
    originatorSignatureValue = that.originatorSignatureValue;
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined Receipt &Receipt::operator = (const Receipt &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
Receipt::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

    l = originatorSignatureValue.BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
    totalLen += l;

    l = signedContentIdentifier.BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
    totalLen += l;

    l = contentType.BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, UNIV, PRIM, OID_TAG_CODE);
    totalLen += l;

    l = version.BEncContent (b);
    BEncDefLenTo127 (b, l);
    l++;

    l += BEncTag1 (b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

  return totalLen;
} // Receipt::BEncContent


void Receipt::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    version.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    SnaccExcep::throwMe(-137);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, OID_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    contentType.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    SnaccExcep::throwMe(-138);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    signedContentIdentifier.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    SnaccExcep::throwMe(-139);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    originatorSignatureValue.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    SnaccExcep::throwMe(-140);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << endl;
    SnaccExcep::throwMe(-141);
  }
  else
    return;
} // Receipt::BDecContent

AsnLen Receipt::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void Receipt::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "Receipt::BDec: ERROR - wrong tag" << endl;
    SnaccExcep::throwMe(-142);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

void Receipt::Print (ostream &os) const
{
#ifndef NDEBUG
  os << "{ -- SEQUENCE --" << endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "version ";
    os << version;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "contentType ";
    os << contentType;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "signedContentIdentifier ";
    os << signedContentIdentifier;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "originatorSignatureValue ";
    os << originatorSignatureValue;
  }

  os << endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
#endif /* NDEBUG */
} // Receipt::Print


ContentHints::ContentHints()
{
  contentDescription = NULL;
}

ContentHints::ContentHints (const ContentHints &)
{
  Asn1Error << "use of incompletely defined ContentHints::ContentHints (const ContentHints &)" << endl;
  abort();
}

ContentHints::~ContentHints()
{
  delete contentDescription;
}

AsnType *ContentHints::Clone() const
{
  return new ContentHints;
}

AsnType *ContentHints::Copy() const
{
  return new ContentHints (*this);
}

#if SNACC_DEEP_COPY
ContentHints &ContentHints::operator = (const ContentHints &that)
#else // SNACC_DEEP_COPY
ContentHints &ContentHints::operator = (const ContentHints &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    if (that.contentDescription)
    {
      if (!contentDescription)
        contentDescription = new UTF8String;
      *contentDescription = *that.contentDescription;
    }
    else
    {
      delete contentDescription;
      contentDescription = NULL;
    }
    contentType = that.contentType;
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined ContentHints &ContentHints::operator = (const ContentHints &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
ContentHints::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

    l = contentType.BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, UNIV, PRIM, OID_TAG_CODE);
    totalLen += l;

  if (NOT_NULL (contentDescription))
  {
    l = contentDescription->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, UNIV, PRIM, 12);
    totalLen += l;
  }

  return totalLen;
} // ContentHints::BEncContent


void ContentHints::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, 12))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, 12)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    contentDescription = new UTF8String;
    contentDescription->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, OID_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    contentType.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    SnaccExcep::throwMe(-143);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << endl;
    SnaccExcep::throwMe(-144);
  }
  else
    return;
} // ContentHints::BDecContent

AsnLen ContentHints::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void ContentHints::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "ContentHints::BDec: ERROR - wrong tag" << endl;
    SnaccExcep::throwMe(-145);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

void ContentHints::Print (ostream &os) const
{
#ifndef NDEBUG
  os << "{ -- SEQUENCE --" << endl;
  indentG += stdIndentG;

  if (NOT_NULL (contentDescription))
  {
    Indent (os, indentG);
    os << "contentDescription ";
    os << *contentDescription;
  }
  else
  {
    Indent (os, indentG);
    os << "contentDescription ";
    os << "-- void --";
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "contentType ";
    os << contentType;
  }

  os << endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
#endif /* NDEBUG */
} // ContentHints::Print


ContentReference::ContentReference()
{
}

ContentReference::ContentReference (const ContentReference &)
{
  Asn1Error << "use of incompletely defined ContentReference::ContentReference (const ContentReference &)" << endl;
  abort();
}

ContentReference::~ContentReference()
{
}

AsnType *ContentReference::Clone() const
{
  return new ContentReference;
}

AsnType *ContentReference::Copy() const
{
  return new ContentReference (*this);
}

#if SNACC_DEEP_COPY
ContentReference &ContentReference::operator = (const ContentReference &that)
#else // SNACC_DEEP_COPY
ContentReference &ContentReference::operator = (const ContentReference &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    contentType = that.contentType;
    signedContentIdentifier = that.signedContentIdentifier;
    originatorSignatureValue = that.originatorSignatureValue;
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined ContentReference &ContentReference::operator = (const ContentReference &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
ContentReference::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

    l = originatorSignatureValue.BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
    totalLen += l;

    l = signedContentIdentifier.BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
    totalLen += l;

    l = contentType.BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, UNIV, PRIM, OID_TAG_CODE);
    totalLen += l;

  return totalLen;
} // ContentReference::BEncContent


void ContentReference::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, OID_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    contentType.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    SnaccExcep::throwMe(-146);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    signedContentIdentifier.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    tag1 = BDecTag (b, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    SnaccExcep::throwMe(-147);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    originatorSignatureValue.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    SnaccExcep::throwMe(-148);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << endl;
    SnaccExcep::throwMe(-149);
  }
  else
    return;
} // ContentReference::BDecContent

AsnLen ContentReference::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void ContentReference::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "ContentReference::BDec: ERROR - wrong tag" << endl;
    SnaccExcep::throwMe(-150);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

void ContentReference::Print (ostream &os) const
{
#ifndef NDEBUG
  os << "{ -- SEQUENCE --" << endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "contentType ";
    os << contentType;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "signedContentIdentifier ";
    os << signedContentIdentifier;
    os << "," << endl;
  }

  {
    Indent (os, indentG);
    os << "originatorSignatureValue ";
    os << originatorSignatureValue;
  }

  os << endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
#endif /* NDEBUG */
} // ContentReference::Print


AsnType *EquivalentLabels::Clone() const
{
  return new EquivalentLabels;
}

AsnType *EquivalentLabels::Copy() const
{
  return new EquivalentLabels (*this);
}

AsnLen EquivalentLabels::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void EquivalentLabels::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "EquivalentLabels::BDec: ERROR - wrong tag" << endl;
    SnaccExcep::throwMe(-151);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

EquivalentLabels::EquivalentLabels (const EquivalentLabels &)
{
  Asn1Error << "use of incompletely defined EquivalentLabels::EquivalentLabels (const EquivalentLabels &)" << endl;
  abort();
}

EquivalentLabels::~EquivalentLabels()
{
  SetCurrToFirst();
  for (; Curr() != NULL; RemoveCurrFromList())
    ;
} // end of destructor

#if SNACC_DEEP_COPY
EquivalentLabels &EquivalentLabels::operator = (const EquivalentLabels &that)
#else // SNACC_DEEP_COPY
EquivalentLabels &EquivalentLabels::operator = (const EquivalentLabels &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    SetCurrToFirst();
    for (; Curr(); RemoveCurrFromList())
      ;

    //that.SetCurrToFirst();
    //for (; that.Curr(); that.GoNext())
    //  AppendCopy (*that.Curr());
    for (const AsnListElmt *run=that.first; run; run=run->next)
      AppendCopy (*run->elmt);
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined EquivalentLabels &EquivalentLabels::operator = (const EquivalentLabels &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

void EquivalentLabels::Print (ostream &os) const
{
#ifndef NDEBUG
    os << "{ -- SEQUENCE/SET OF -- " << endl;
    indentG += stdIndentG;
    //SetCurrToFirst();
    //for (; Curr() != NULL; GoNext())
    for (const AsnListElmt *run=first; run; run=run->next)
    {
        Indent (os, indentG);
        //os << *Curr();
        os << *run->elmt;
        //if (Curr() != Last())
        if (run != last)
            os << ",";
        os << endl;
    }
    indentG -= stdIndentG;
    Indent (os, indentG);
    os << "}\n";
#endif /* NDEBUG */


} // Print


void  EquivalentLabels::SetCurrElmt (unsigned long int index)
{
  unsigned long int i;
  curr = first;
  if (count)
    for (i = 0; (i < (count-1)) && (i < index); i++)
      curr = curr->next;
} // EquivalentLabels::SetCurrElmt


unsigned long int  EquivalentLabels::GetCurrElmtIndex()
{
    unsigned long int i;
    AsnListElmt *tmp;
    if (curr != NULL)
    {
        for (i = 0, tmp = first; tmp != NULL; i++)
        {
            if (tmp == curr)
                return i;
            else
                tmp = tmp->next;
        }
    }
    return count;
} // EquivalentLabels::GetCurrElmtIndex


// alloc new list elmt, put at end of list
//  and return the component type
ESSSecurityLabel *EquivalentLabels::Append()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new ESSSecurityLabel;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // EquivalentLabels::Append


// alloc new list elmt, put at begining of list
//  and return the component type
ESSSecurityLabel  *EquivalentLabels::Prepend()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new ESSSecurityLabel;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // EquivalentLabels::Prepend


// alloc new list elmt, insert it before the
// current element and return the component type
// if the current element is null, the new element
// is placed at the beginning of the list.
ESSSecurityLabel  *EquivalentLabels::InsertBefore()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new ESSSecurityLabel;
    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // EquivalentLabels::InsertBefore


// alloc new list elmt, insert it after the
// current element and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
ESSSecurityLabel *EquivalentLabels::InsertAfter()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new ESSSecurityLabel;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // EquivalentLabels::InsertAfter


EquivalentLabels  &EquivalentLabels::AppendCopy (ESSSecurityLabel &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new ESSSecurityLabel;
    *newElmt->elmt = elmt;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return *this;
} // AppendCopy


EquivalentLabels  &EquivalentLabels::PrependCopy (ESSSecurityLabel &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new ESSSecurityLabel;
    *newElmt->elmt = elmt;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return *this;
} // EquivalentLabels::PrependCopy


// alloc new list elmt, insert it before the
// current element, copy the given elmt into the new elmt
// and return the component type.
// if the current element is null, the new element
// is placed at the beginning of the list.
EquivalentLabels &EquivalentLabels::InsertBeforeAndCopy (ESSSecurityLabel &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new ESSSecurityLabel;
    *newElmt->elmt = elmt;

    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return *this;
} // EquivalentLabels::InsertBeforeAndCopy


// alloc new list elmt, insert it after the
// current element, copy given elmt in to new elmt
//  and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
EquivalentLabels  &EquivalentLabels::InsertAfterAndCopy (ESSSecurityLabel &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new ESSSecurityLabel;
    *newElmt->elmt = elmt;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return *this;
} // EquivalentLabels::InsertAfterAndCopy


// remove current element from list if current element is not NULL 
// The new current element will be the next element.
// If the current element is the last element in the list
// the second but last element will become the new current element.
void EquivalentLabels::RemoveCurrFromList()
{
    AsnListElmt *del_elmt;

    if (curr != NULL)
    {
        del_elmt = curr;
        count--;

        if (count == 0)
            first = last = curr = NULL;
        else if (curr == first)
        {
            curr = first= first->next;
            first->prev = NULL;
        }
        else if (curr == last)
        {
            curr = last = last->prev;
            last->next = NULL;
        }
        else
        {
            curr->prev->next = curr->next;
            curr->next->prev = curr->prev;
        }

        delete del_elmt->elmt;
        delete del_elmt;
    }
}


AsnLen EquivalentLabels::BEncContent (BUF_TYPE b)
{
    AsnListElmt *currElmt;
    AsnLen elmtLen;
    AsnLen totalLen = 0;
    for (currElmt = last; currElmt != NULL; currElmt = currElmt->prev)
    {
      BEncEocIfNec (b);
        elmtLen = currElmt->elmt->BEncContent (b);
    elmtLen += BEncConsLen (b, elmtLen);

    elmtLen += BEncTag1 (b, UNIV, CONS, SET_TAG_CODE);
        totalLen += elmtLen;
    }
    return totalLen;
} // EquivalentLabels::BEncContent


void  EquivalentLabels::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0,
                                  AsnLen &bytesDecoded, ENV_TYPE env)
{
    ESSSecurityLabel *listElmt;
    AsnTag tag1;
    AsnLen listBytesDecoded = 0;
    AsnLen elmtLen1;

    while ((listBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN))
    {
        tag1 = BDecTag (b, listBytesDecoded, env);
        if ((tag1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
        {
            BDEC_2ND_EOC_OCTET (b, listBytesDecoded, env);
            break;
        }
        if ((tag1 != MAKE_TAG_ID (UNIV, CONS, SET_TAG_CODE)))
        {
            Asn1Error << "Unexpected Tag" << endl;
            SnaccExcep::throwMe(-152);
        }

        elmtLen1 = BDecLen (b, listBytesDecoded, env);
        listElmt = Append();
        listElmt->BDecContent (b, tag1, elmtLen1, listBytesDecoded, env);
    }

    bytesDecoded += listBytesDecoded;
} // EquivalentLabels::BDecContent


AsnType *MLExpansionHistory::Clone() const
{
  return new MLExpansionHistory;
}

AsnType *MLExpansionHistory::Copy() const
{
  return new MLExpansionHistory (*this);
}

AsnLen MLExpansionHistory::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void MLExpansionHistory::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "MLExpansionHistory::BDec: ERROR - wrong tag" << endl;
    SnaccExcep::throwMe(-153);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

MLExpansionHistory::MLExpansionHistory (const MLExpansionHistory &)
{
  Asn1Error << "use of incompletely defined MLExpansionHistory::MLExpansionHistory (const MLExpansionHistory &)" << endl;
  abort();
}

MLExpansionHistory::~MLExpansionHistory()
{
  SetCurrToFirst();
  for (; Curr() != NULL; RemoveCurrFromList())
    ;
} // end of destructor

#if SNACC_DEEP_COPY
MLExpansionHistory &MLExpansionHistory::operator = (const MLExpansionHistory &that)
#else // SNACC_DEEP_COPY
MLExpansionHistory &MLExpansionHistory::operator = (const MLExpansionHistory &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    SetCurrToFirst();
    for (; Curr(); RemoveCurrFromList())
      ;

    //that.SetCurrToFirst();
    //for (; that.Curr(); that.GoNext())
    //  AppendCopy (*that.Curr());
    for (const AsnListElmt *run=that.first; run; run=run->next)
      AppendCopy (*run->elmt);
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined MLExpansionHistory &MLExpansionHistory::operator = (const MLExpansionHistory &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

void MLExpansionHistory::Print (ostream &os) const
{
#ifndef NDEBUG
    os << "{ -- SEQUENCE/SET OF -- " << endl;
    indentG += stdIndentG;
    //SetCurrToFirst();
    //for (; Curr() != NULL; GoNext())
    for (const AsnListElmt *run=first; run; run=run->next)
    {
        Indent (os, indentG);
        //os << *Curr();
        os << *run->elmt;
        //if (Curr() != Last())
        if (run != last)
            os << ",";
        os << endl;
    }
    indentG -= stdIndentG;
    Indent (os, indentG);
    os << "}\n";
#endif /* NDEBUG */


} // Print


void  MLExpansionHistory::SetCurrElmt (unsigned long int index)
{
  unsigned long int i;
  curr = first;
  if (count)
    for (i = 0; (i < (count-1)) && (i < index); i++)
      curr = curr->next;
} // MLExpansionHistory::SetCurrElmt


unsigned long int  MLExpansionHistory::GetCurrElmtIndex()
{
    unsigned long int i;
    AsnListElmt *tmp;
    if (curr != NULL)
    {
        for (i = 0, tmp = first; tmp != NULL; i++)
        {
            if (tmp == curr)
                return i;
            else
                tmp = tmp->next;
        }
    }
    return count;
} // MLExpansionHistory::GetCurrElmtIndex


// alloc new list elmt, put at end of list
//  and return the component type
MLData *MLExpansionHistory::Append()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt  = new MLData;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // MLExpansionHistory::Append


// alloc new list elmt, put at begining of list
//  and return the component type
MLData  *MLExpansionHistory::Prepend()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new MLData;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // MLExpansionHistory::Prepend


// alloc new list elmt, insert it before the
// current element and return the component type
// if the current element is null, the new element
// is placed at the beginning of the list.
MLData  *MLExpansionHistory::InsertBefore()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new MLData;
    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // MLExpansionHistory::InsertBefore


// alloc new list elmt, insert it after the
// current element and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
MLData *MLExpansionHistory::InsertAfter()
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new MLData;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return (curr = newElmt)->elmt;
} // MLExpansionHistory::InsertAfter


MLExpansionHistory  &MLExpansionHistory::AppendCopy (MLData &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new MLData;
    *newElmt->elmt = elmt;
    newElmt->next = NULL;
    if (last == NULL)
    {
        newElmt->prev = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->prev = last;
        last->next    = newElmt;
        last          = newElmt;
    }
    count++;
    return *this;
} // AppendCopy


MLExpansionHistory  &MLExpansionHistory::PrependCopy (MLData &elmt)
{
    AsnListElmt *newElmt;
    newElmt  = new AsnListElmt;
    newElmt->elmt = new MLData;
    *newElmt->elmt = elmt;
    newElmt->prev = NULL;
    if (first == NULL)
    {
        newElmt->next = NULL;
        first = last  = newElmt;
    }
    else
    {
        newElmt->next = first;
        first->prev   = newElmt;
        first         = newElmt;
    }
    count++;
    return *this;
} // MLExpansionHistory::PrependCopy


// alloc new list elmt, insert it before the
// current element, copy the given elmt into the new elmt
// and return the component type.
// if the current element is null, the new element
// is placed at the beginning of the list.
MLExpansionHistory &MLExpansionHistory::InsertBeforeAndCopy (MLData &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new MLData;
    *newElmt->elmt = elmt;

    if (curr == NULL)
    {
        newElmt->next = first;
        newElmt->prev = NULL;
        first = newElmt;
        if (last == NULL)
            last = newElmt;
    }
    else
    {
        newElmt->next = curr;
        newElmt->prev = curr->prev;
        curr->prev = newElmt;
        if (curr == first)
            first = newElmt;
        else
            newElmt->prev->next = newElmt;
    }
    count++;
    return *this;
} // MLExpansionHistory::InsertBeforeAndCopy


// alloc new list elmt, insert it after the
// current element, copy given elmt in to new elmt
//  and return the component type
// if the current element is null, the new element
// is placed at the end of the list.
MLExpansionHistory  &MLExpansionHistory::InsertAfterAndCopy (MLData &elmt)
{
    AsnListElmt *newElmt;

    newElmt  = new AsnListElmt;
    newElmt->elmt = new MLData;
    *newElmt->elmt = elmt;
    if (curr == NULL)
    {
        newElmt->prev = last;
        newElmt->next = NULL;
        last = newElmt;
        if (first == NULL)
            first = newElmt;
    }
    else
    {
        newElmt->prev = curr;
        newElmt->next = curr->next;
        curr->next = newElmt;
        if (curr == last)
            last = newElmt;
        else
            newElmt->next->prev = newElmt;
    }
    count++;
    return *this;
} // MLExpansionHistory::InsertAfterAndCopy


// remove current element from list if current element is not NULL 
// The new current element will be the next element.
// If the current element is the last element in the list
// the second but last element will become the new current element.
void MLExpansionHistory::RemoveCurrFromList()
{
    AsnListElmt *del_elmt;

    if (curr != NULL)
    {
        del_elmt = curr;
        count--;

        if (count == 0)
            first = last = curr = NULL;
        else if (curr == first)
        {
            curr = first= first->next;
            first->prev = NULL;
        }
        else if (curr == last)
        {
            curr = last = last->prev;
            last->next = NULL;
        }
        else
        {
            curr->prev->next = curr->next;
            curr->next->prev = curr->prev;
        }

        delete del_elmt->elmt;
        delete del_elmt;
    }
}


AsnLen MLExpansionHistory::BEncContent (BUF_TYPE b)
{
    AsnListElmt *currElmt;
    AsnLen elmtLen;
    AsnLen totalLen = 0;
    for (currElmt = last; currElmt != NULL; currElmt = currElmt->prev)
    {
      BEncEocIfNec (b);
        elmtLen = currElmt->elmt->BEncContent (b);
    elmtLen += BEncConsLen (b, elmtLen);

    elmtLen += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
        totalLen += elmtLen;
    }
    return totalLen;
} // MLExpansionHistory::BEncContent


void  MLExpansionHistory::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0,
                                  AsnLen &bytesDecoded, ENV_TYPE env)
{
    MLData *listElmt;
    AsnTag tag1;
    AsnLen listBytesDecoded = 0;
    AsnLen elmtLen1;

    while ((listBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN))
    {
        tag1 = BDecTag (b, listBytesDecoded, env);
        if ((tag1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
        {
            BDEC_2ND_EOC_OCTET (b, listBytesDecoded, env);
            break;
        }
        if ((tag1 != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
        {
            Asn1Error << "Unexpected Tag" << endl;
            SnaccExcep::throwMe(-154);
        }

        elmtLen1 = BDecLen (b, listBytesDecoded, env);
        listElmt = Append();
        listElmt->BDecContent (b, tag1, elmtLen1, listBytesDecoded, env);
    }

    bytesDecoded += listBytesDecoded;
} // MLExpansionHistory::BDecContent


SigningCertificate::SigningCertificate()
{
  policies = NULL;
}

SigningCertificate::SigningCertificate (const SigningCertificate &)
{
  Asn1Error << "use of incompletely defined SigningCertificate::SigningCertificate (const SigningCertificate &)" << endl;
  abort();
}

SigningCertificate::~SigningCertificate()
{
  delete policies;
}

AsnType *SigningCertificate::Clone() const
{
  return new SigningCertificate;
}

AsnType *SigningCertificate::Copy() const
{
  return new SigningCertificate (*this);
}

#if SNACC_DEEP_COPY
SigningCertificate &SigningCertificate::operator = (const SigningCertificate &that)
#else // SNACC_DEEP_COPY
SigningCertificate &SigningCertificate::operator = (const SigningCertificate &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    certs = that.certs;
    if (that.policies)
    {
      if (!policies)
        policies = new SigningCertificateSeqOf1;
      *policies = *that.policies;
    }
    else
    {
      delete policies;
      policies = NULL;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined SigningCertificate &SigningCertificate::operator = (const SigningCertificate &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
SigningCertificate::BEncContent (BUF_TYPE b)
{
  AsnLen totalLen = 0;
  AsnLen l;

  if (NOT_NULL (policies))
  {
      BEncEocIfNec (b);
    l = policies->BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;
  }

      BEncEocIfNec (b);
    l = certs.BEncContent (b);
    l += BEncConsLen (b, l);

    l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;

  return totalLen;
} // SigningCertificate::BEncContent


void SigningCertificate::BDecContent (BUF_TYPE b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag1;
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1;
  tag1 = BDecTag (b, seqBytesDecoded, env);

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    certs.BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (b, seqBytesDecoded, env);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (b, seqBytesDecoded, env)
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
    Asn1Error << "ERROR - SEQUENCE is missing non-optional elmt." << endl;
    SnaccExcep::throwMe(-155);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
  {
    elmtLen1 = BDecLen (b, seqBytesDecoded, env);
    policies = new SigningCertificateSeqOf1;
    policies->BDecContent (b, tag1, elmtLen1, seqBytesDecoded, env);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (b, bytesDecoded, env);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    Asn1Error << "ERROR - Length discrepancy on sequence." << endl;
    SnaccExcep::throwMe(-156);
  }
  else
    return;
} // SigningCertificate::BDecContent

AsnLen SigningCertificate::BEnc (BUF_TYPE b)
{
  AsnLen l;
  l = BEncContent (b);
  l += BEncConsLen (b, l);
  l += BEncTag1 (b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void SigningCertificate::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (b, bytesDecoded, env)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    Asn1Error << "SigningCertificate::BDec: ERROR - wrong tag" << endl;
    SnaccExcep::throwMe(-157);
  }
  elmtLen1 = BDecLen (b, bytesDecoded, env);
  BDecContent (b, tag, elmtLen1, bytesDecoded, env);
}

void SigningCertificate::Print (ostream &os) const
{
#ifndef NDEBUG
  os << "{ -- SEQUENCE --" << endl;
  indentG += stdIndentG;

  {
    Indent (os, indentG);
    os << "certs ";
    os << certs;
    os << "," << endl;
  }

  if (NOT_NULL (policies))
  {
    os << ","<< endl;
    Indent (os, indentG);
    os << "policies ";
    os << *policies;
  }
  else
  {
    Indent (os, indentG);
    os << "policies ";
    os << "-- void --";
    os << endl;
  }

  os << endl;
  indentG -= stdIndentG;
  Indent (os, indentG);
  os << "}";
#endif /* NDEBUG */
} // SigningCertificate::Print


