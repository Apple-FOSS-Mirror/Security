//   NOTE: this is a machine generated file--editing not recommended
//
// sm_x520sa.cpp - class member functions for ASN.1 module SelectedAttributeTypes
//
//   This file was generated by snacc on Mon Apr 22 22:34:19 2002
//   UBC snacc written by Mike Sample
//   A couple of enhancements made by IBM European Networking Center


#include "asn-incl.h"
#include "sm_vdatypes.h"
#include "sm_x501ud.h"
#include "sm_x411ub.h"
#include "sm_x411mtsas.h"
#include "sm_x501if.h"
#include "sm_x520sa.h"
#include "sm_x509cmn.h"
#include "sm_x509af.h"
#include "sm_x509ce.h"
#include "pkcs1oids.h"
#include "pkcs9oids.h"
#include "sm_cms.h"
#include "sm_ess.h"
#include "pkcs7.h"
#include "pkcs8.h"
#include "appleoids.h"
#include "pkcs10.h"

//------------------------------------------------------------------------------
// value defs


//------------------------------------------------------------------------------
// class member definitions:

DirectoryString::DirectoryString()
{
  choiceId = teletexStringCid;
#if TCL
  teletexString = new TeletexString;
#else
  teletexString = NULL; // incomplete initialization of mandatory element!
#endif // TCL
}

DirectoryString::DirectoryString (const DirectoryString &)
{
  Asn1Error << "use of incompletely defined DirectoryString::DirectoryString (const DirectoryString &)" << endl;
  abort();
}

DirectoryString::~DirectoryString()
{
  switch (choiceId)
  {
    case teletexStringCid:
      delete teletexString;
      break;
    case printableStringCid:
      delete printableString;
      break;
    case universalStringCid:
      delete universalString;
      break;
    case bmpStringCid:
      delete bmpString;
      break;
    case utf8StringCid:
      delete utf8String;
      break;
  } // end of switch
} // end of destructor

AsnType *DirectoryString::Clone() const
{
  return new DirectoryString;
}

AsnType *DirectoryString::Copy() const
{
  return new DirectoryString (*this);
}

#if SNACC_DEEP_COPY
DirectoryString &DirectoryString::operator = (const DirectoryString &that)
#else // SNACC_DEEP_COPY
DirectoryString &DirectoryString::operator = (const DirectoryString &)
#endif // SNACC_DEEP_COPY
{
#if SNACC_DEEP_COPY
  if (this != &that)
  {
    switch (choiceId)
    {
      case teletexStringCid:
        delete teletexString;
        break;
      case printableStringCid:
        delete printableString;
        break;
      case universalStringCid:
        delete universalString;
        break;
      case bmpStringCid:
        delete bmpString;
        break;
      case utf8StringCid:
        delete utf8String;
        break;
    }
    switch (choiceId = that.choiceId)
    {
      case teletexStringCid:
        teletexString = new TeletexString;
        *teletexString = *that.teletexString;
        break;
      case printableStringCid:
        printableString = new PrintableString;
        *printableString = *that.printableString;
        break;
      case universalStringCid:
        universalString = new UniversalString;
        *universalString = *that.universalString;
        break;
      case bmpStringCid:
        bmpString = new BMPString;
        *bmpString = *that.bmpString;
        break;
      case utf8StringCid:
        utf8String = new UTF8String;
        *utf8String = *that.utf8String;
        break;
    }
  }

  return *this;
#else // SNACC_DEEP_COPY
  Asn1Error << "use of incompletely defined DirectoryString &DirectoryString::operator = (const DirectoryString &)" << endl;
  abort();
  // if your compiler complains here, check the -novolat option
#endif // SNACC_DEEP_COPY
}

AsnLen
DirectoryString::BEncContent (BUF_TYPE b)
{
  AsnLen l;
  switch (choiceId)
  {
    case teletexStringCid:
      l = teletexString->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, UNIV, PRIM, TELETEXSTRING_TAG_CODE);
      break;

    case printableStringCid:
      l = printableString->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, UNIV, PRIM, PRINTABLESTRING_TAG_CODE);
      break;

    case universalStringCid:
      l = universalString->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, UNIV, PRIM, UNIVERSALSTRING_TAG_CODE);
      break;

    case bmpStringCid:
      l = bmpString->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, UNIV, PRIM, BMPSTRING_TAG_CODE);
      break;

    case utf8StringCid:
      l = utf8String->BEncContent (b);
    l += BEncDefLen (b, l);

    l += BEncTag1 (b, UNIV, PRIM, 12);
      break;

  } // end switch
  return l;
} // DirectoryString::BEncContent


void DirectoryString::BDecContent (BUF_TYPE b, AsnTag tag, AsnLen elmtLen0, AsnLen &bytesDecoded, ENV_TYPE env)
{
  switch (tag)
  {
    case MAKE_TAG_ID (UNIV, PRIM, TELETEXSTRING_TAG_CODE):
    case MAKE_TAG_ID (UNIV, CONS, TELETEXSTRING_TAG_CODE):
      choiceId = teletexStringCid;
      teletexString = new TeletexString;
        teletexString->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (UNIV, PRIM, PRINTABLESTRING_TAG_CODE):
    case MAKE_TAG_ID (UNIV, CONS, PRINTABLESTRING_TAG_CODE):
      choiceId = printableStringCid;
      printableString = new PrintableString;
        printableString->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (UNIV, PRIM, UNIVERSALSTRING_TAG_CODE):
    case MAKE_TAG_ID (UNIV, CONS, UNIVERSALSTRING_TAG_CODE):
      choiceId = universalStringCid;
      universalString = new UniversalString;
        universalString->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (UNIV, PRIM, BMPSTRING_TAG_CODE):
    case MAKE_TAG_ID (UNIV, CONS, BMPSTRING_TAG_CODE):
      choiceId = bmpStringCid;
      bmpString = new BMPString;
        bmpString->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    case MAKE_TAG_ID (UNIV, PRIM, 12):
    case MAKE_TAG_ID (UNIV, CONS, 12):
      choiceId = utf8StringCid;
      utf8String = new UTF8String;
        utf8String->BDecContent (b, tag, elmtLen0, bytesDecoded, env);
      break;

    default:
      Asn1Error << "ERROR - unexpected tag in CHOICE" << endl;
      SnaccExcep::throwMe(-100);
      break;
  } // end switch
} // DirectoryString::BDecContent


AsnLen DirectoryString::BEnc (BUF_TYPE b)
{
    AsnLen l;
    l = BEncContent (b);
    return l;
}

void DirectoryString::BDec (BUF_TYPE b, AsnLen &bytesDecoded, ENV_TYPE env)
{
    AsnLen elmtLen;
    AsnTag tag;

    /*  CHOICEs are a special case - grab identifying tag */
    /*  this allows easier handling of nested CHOICEs */
    tag = BDecTag (b, bytesDecoded, env);
    elmtLen = BDecLen (b, bytesDecoded, env);
    BDecContent (b, tag, elmtLen, bytesDecoded, env);
}

void DirectoryString::Print (ostream &os) const
{
#ifndef NDEBUG
  switch (choiceId)
  {
    case teletexStringCid:
      os << "teletexString ";
      if (teletexString)
        os << *teletexString;
      else
        os << "-- void3 --\n";
      break;

    case printableStringCid:
      os << "printableString ";
      if (printableString)
        os << *printableString;
      else
        os << "-- void3 --\n";
      break;

    case universalStringCid:
      os << "universalString ";
      if (universalString)
        os << *universalString;
      else
        os << "-- void3 --\n";
      break;

    case bmpStringCid:
      os << "bmpString ";
      if (bmpString)
        os << *bmpString;
      else
        os << "-- void3 --\n";
      break;

    case utf8StringCid:
      os << "utf8String ";
      if (utf8String)
        os << *utf8String;
      else
        os << "-- void3 --\n";
      break;

  } // end of switch
#endif /* NDEBUG */
} // DirectoryString::Print

